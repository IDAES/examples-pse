Flowsheet Plug Flow Reactor (PFR) Simulation and Optimization of Ethylene Glycol Production
===========================================================================================

Learning Outcomes
-----------------

-  Call and implement the IDAES PFR unit model
-  Construct a steady-state flowsheet using the IDAES unit model library
-  Connecting unit models in a flowsheet using Arcs
-  Fomulate and solve an optimization problem

   -  Defining an objective function
   -  Setting variable bounds
   -  Adding additional constraints

Problem Statement
-----------------

Following the previous example implementing a `Continuous Stirred Tank
Reactor (CSTR) unit
model <http://localhost:8888/notebooks/GitHub/examples-pse/src/Examples/UnitModels/Reactors/cstr_testing.ipynb>`__,
we can alter the flowsheet to use a plug flow reactor (PFR). As before,
this example is adapted from Fogler, H.S., Elements of Chemical Reaction
Engineering 5th ed., 2016, Prentice Hall, p. 157-160 with the following
chemical reaction, property packages and flowsheet. Unlike a CSTR which
assumes well-mixed liquid behavior, the concentration profiles will vary
spatially in one dimension. In actuality, following start-up flow
reactor exhibit dynamic behavior as they approach a steady-state
equilibrium; we will assume our system has already achieved steady-state
behavior. The state variables chosen for the property package are
**molar flows of each component by phase in each stream, temperature of
each stream and pressure of each stream**. The components considered
are: **ethylene oxide, water, sulfuric acid and ethylene glycol** and
the process occurs in liquid phase only. Therefore, every stream has 4
flow variables, 1 temperature and 1 pressure variable.

Chemical reaction:

**C2H4O + H2O + H2SO4 → C2H6O2 + H2SO4**

Property Packages:

-  egprod_ideal.py
-  egprod_reaction.py

Flowsheet:

.. image:: egprod_flowsheet.png

Importing Required Pyomo and IDAES components
---------------------------------------------

To construct a flowsheet, we will need several components from the Pyomo
and IDAES packages. Let us first import the following components from
Pyomo: - Constraint (to write constraints) - Var (to declare variables)
- ConcreteModel (to create the concrete model object) - Expression (to
evaluate values as a function of variables defined in the model) -
Objective (to define an objective function for optimization) -
TransformationFactory (to apply certain transformations) - Arc (to
connect two unit models)

For further details on these components, please refer to the pyomo
documentation: https://pyomo.readthedocs.io/en/latest/

From idaes, we will be needing the ``FlowsheetBlock`` and the following
unit models: - Mixer - Heater - PFR

We will also be needing some utility tools to put together the flowsheet
and calculate the degrees of freedom, tools for model expressions and
calling variable values, and built-in functions to define property
packages, add unit containers to objects and define our initialization
scheme.

.. code:: ipython3

    from pyomo.environ import (Constraint,
                               Var,
                               ConcreteModel,
                               Expression,
                               Objective,
                               TransformationFactory,
                               value,
                               units as pyunits)
    from pyomo.network import Arc
    
    from idaes.core import FlowsheetBlock
    from idaes.models.properties.modular_properties import (
            GenericParameterBlock,
            GenericReactionParameterBlock)
    from idaes.models.unit_models import (Feed,
                                          Mixer,
                                          Heater,
                                          PFR,
                                          Product)
    
    from idaes.core.solvers import get_solver
    from idaes.core.util.model_statistics import degrees_of_freedom
    from idaes.core.util.initialization import propagate_state

Importing Required Thermophysical and Reaction Packages
-------------------------------------------------------

The final step is to import the thermophysical and reaction packages. We
have created a custom thermophysical package that support ideal vapor
and liquid behavior for this system, and in this case we will restrict
it to ideal liquid behavior only.

The reaction package here assumes Arrhenius kinetic behavior for the
PFR, for which :math:`k_0` and :math:`E_a` are known *a priori* (if
unknown, they may be obtained using one of the parameter estimation
tools within IDAES).

$ r = -kVC_{EO} $, $ k = k_0 e^{(-E_a/RT)}$, with the variables as
follows:

| :math:`r` - reaction rate extent in moles of ethylene oxide consumed
  per second; note that the traditional reaction rate would be given by
  :math:`rate = r/V` in moles per :math:`m^3` per second
| :math:`k` - reaction rate constant per second
| :math:`V` - volume of PFR in :math:`m^3`, note that this is *liquid
  volume* and not the *total volume* of the reactor itself
| :math:`C_{EO}` - bulk concentration of ethylene oxide in moles per
  :math:`m^3` (the limiting reagent, since we assume excess catalyst and
  water)
| :math:`k_0` - pre-exponential Arrhenius factor per second
| :math:`E_a` - reaction activation energy in kJ per mole of ethylene
  oxide consumed
| :math:`R` - gas constant in J/mol-K
| :math:`T` - reactor temperature in K

These calculations are contained within the property, reaction and unit
model packages, and do not need to be entered into the flowsheet. More
information on property estimation may be found in the IDAES
documentation on `Parameter
Estimation <https://idaes-pse.readthedocs.io/en/stable/how_to_guides/workflow/data_rec_parmest.html>`__.

Let us import the following modules from the same directory as this
Jupyter notebook: - egprod_ideal as thermo_props - egprod_reaction as
reaction_props

.. code:: ipython3

    import egprod_ideal as thermo_props
    import egprod_reaction as reaction_props

Constructing the Flowsheet
--------------------------

We have now imported all the components, unit models, and property
modules we need to construct a flowsheet. Let us create a ConcreteModel
and add the flowsheet block.

.. code:: ipython3

    m = ConcreteModel()
    m.fs = FlowsheetBlock(dynamic=False)

We now need to add the property packages to the flowsheet. Unlike the
basic `Flash unit model
example <http://localhost:8888/notebooks/GitHub/examples-pse/src/Tutorials/Basics/flash_unit_solution_testing.ipynb>`__,
where we only had a thermophysical property package, for this flowsheet
we will also need to add a reaction property package. We will use the
`Modular Property
Framework <https://idaes-pse.readthedocs.io/en/stable/explanations/components/property_package/index.html#generic-property-package-framework>`__
and `Modular Reaction
Framework <https://idaes-pse.readthedocs.io/en/stable/explanations/components/property_package/index.html#generic-reaction-package-framework>`__.
The get_prop method for the natural gas property module automatically
returns the correct dictionary using a component list argument. The
GenericParameterBlock and GenericReactionParameterBlock methods build
states blocks from passed parameter data; the reaction block unpacks
using \**reaction_props.config_dict to allow for optional or empty
keyword arguments:

.. code:: ipython3

    m.fs.thermo_params = GenericParameterBlock(**thermo_props.config_dict)
    m.fs.reaction_params = GenericReactionParameterBlock(property_package=m.fs.thermo_params,
                                                         **reaction_props.config_dict)

Adding Unit Models
------------------

Let us start adding the unit models we have imported to the flowsheet.
Here, we are adding a ``Mixer``, a ``Heater`` and a ``PFR``. Note that
all unit models need to be given a property package argument. In
addition to that, there are several arguments depending on the unit
model, please refer to the documentation for more details on `IDAES Unit
Models <https://idaes-pse.readthedocs.io/en/stable/reference_guides/model_libraries/index.html>`__.
For example, the ``Mixer`` is given a ``list`` consisting of names to
the two inlets.

.. code:: ipython3

    m.fs.OXIDE = Feed(property_package=m.fs.thermo_params)
    m.fs.ACID = Feed(property_package=m.fs.thermo_params)
    m.fs.PROD = Product(property_package=m.fs.thermo_params)
    m.fs.M101 = Mixer(property_package=m.fs.thermo_params,
                      inlet_list=["reagent_feed", "catalyst_feed"])
    m.fs.H101 = Heater(property_package=m.fs.thermo_params,
                       has_pressure_change=False,
                       has_phase_equilibrium=False)

.. code:: ipython3

    m.fs.R101 = PFR(property_package=m.fs.thermo_params,
                    reaction_package=m.fs.reaction_params,
                    has_equilibrium_reactions=False,
                    has_heat_of_reaction=True,
                    has_heat_transfer=True,
                    has_pressure_change=False,
                    transformation_method="dae.finite_difference",
                    transformation_scheme="BACKWARD",
                    finite_elements=20)

Connecting Unit Models Using Arcs
---------------------------------

We have now added all the unit models we need to the flowsheet. However,
we have not yet specifed how the units are to be connected. To do this,
we will be using the ``Arc`` which is a pyomo component that takes in
two arguments: ``source`` and ``destination``. Let us connect the outlet
of the ``Mixer`` to the inlet of the ``Heater``, and the outlet of the
``Heater`` to the inlet of the ``PFR``. Additionally, we will connect
the ``Feed`` and ``Product`` blocks to the flowsheet:

.. code:: ipython3

    m.fs.s01 = Arc(source=m.fs.OXIDE.outlet, destination=m.fs.M101.reagent_feed)
    m.fs.s02 = Arc(source=m.fs.ACID.outlet, destination=m.fs.M101.catalyst_feed)
    m.fs.s03 = Arc(source=m.fs.M101.outlet, destination=m.fs.H101.inlet)
    m.fs.s04 = Arc(source=m.fs.H101.outlet, destination=m.fs.R101.inlet)
    m.fs.s05 = Arc(source=m.fs.R101.outlet, destination=m.fs.PROD.inlet)

We have now connected the unit model block using the arcs. However, we
also need to link the state variables on connected ports. Pyomo provides
a convenient method ``TransformationFactory`` to write these equality
constraints for us between two ports:

.. code:: ipython3

    TransformationFactory("network.expand_arcs").apply_to(m)

Adding Expressions to Compute Operating Costs
---------------------------------------------

In this section, we will add a few Expressions that allows us to
evaluate the performance. ``Expressions`` provide a convenient way of
calculating certain values that are a function of the variables defined
in the model. For more details on ``Expressions``, please refer to the
`Pyomo Expression
documentaiton <https://pyomo.readthedocs.io/en/latest/pyomo_modeling_components/Expressions.html>`__.

For this flowsheet, we are interested in computing ethylene glycol
production in millions of pounds per year, as well as the total costs
due to cooling and heating utilities.

Let us first add an ``Expression`` to convert the product flow from
mol/s to MM lb/year of ethylene glycol. We see that the molecular weight
exists in the thermophysical property package, so we may use that value
for our calculations.

.. code:: ipython3

    m.fs.eg_prod = Expression(expr=pyunits.convert(m.fs.PROD.inlet.flow_mol_phase_comp[0, "Liq", "ethylene_glycol"]
                                                   *m.fs.thermo_params.ethylene_glycol.mw, # MW defined in properties as kg/mol
                                                   to_units=pyunits.Mlb/pyunits.yr)) # converting kg/s to MM lb/year

Now, let us add expressions to compute the reactor cooling cost
(\\\ :math:`/s) assuming a cost of 2.12E-5 \\`/kW, and the heating
utility cost (\\\ :math:`/s) assuming 2.2E-4 \\`/kW. Note that the heat
duty is in units of watt (J/s). The total operating cost will be the sum
of the two, expressed in \\$/year assuming 8000 operating hours per year
(~10% downtime, which is fairly common for small scale chemical plants):

.. code:: ipython3

    m.fs.cooling_cost = Expression(expr=2.12e-8 * (-sum(m.fs.R101.heat_duty[0, x]
                                                         for x in m.fs.R101.control_volume.length_domain)))  # the reaction is exothermic, so R101 duty is negative
    m.fs.heating_cost = Expression(expr=2.2e-7 * m.fs.H101.heat_duty[0])  # the stream must be heated to T_rxn, so H101 duty is positive
    m.fs.operating_cost = Expression(expr=(3600 * 8000 *(m.fs.heating_cost + m.fs.cooling_cost)))

Fixing Feed Conditions
----------------------

Let us first check how many degrees of freedom exist for this flowsheet
using the ``degrees_of_freedom`` tool we imported earlier. We expect
each stream to have 6 degrees of freedom, the mixer to have 0 (after
both streams are accounted for), the heater to have 1 (just the duty,
since the inlet is also the outlet of M101), and the reactor to have 2
unit specifications and 1 specification for each finite element.
Therefore, we have 35 degrees of freedom to specify: temperature,
pressure and flow of all four components on both streams; outlet heater
temperature; a reactor property such as conversion or heat duty at each
finite element; reactor volume and reactor length.

.. code:: ipython3

    print(degrees_of_freedom(m))


.. parsed-literal::

    35


We will now be fixing the feed stream to the conditions shown in the
flowsheet above. As mentioned in other tutorials, the IDAES framework
expects a time index value for every referenced internal stream or unit
variable, even in steady-state systems with a single time point $ t = 0
$ (``t = [0]`` is the default when creating a ``FlowsheetBlock`` without
passing a ``time_set`` argument). The non-present components in each
stream are assigned a very small non-zero value to help with convergence
and initializing. Based on stoichiometric ratios for the reaction, 80%
conversion and 200 MM lb/year (46.4 mol/s) of ethylene glycol, we will
initialize our simulation with the following calculated values:

.. code:: ipython3

    m.fs.OXIDE.outlet.flow_mol_phase_comp[0, "Liq", "ethylene_oxide"].fix(58.0*pyunits.mol/pyunits.s)
    m.fs.OXIDE.outlet.flow_mol_phase_comp[0, "Liq", "water"].fix(39.6*pyunits.mol/pyunits.s)  # calculated from 16.1 mol EO / cudm in stream
    m.fs.OXIDE.outlet.flow_mol_phase_comp[0, "Liq", "sulfuric_acid"].fix(1e-5*pyunits.mol/pyunits.s)
    m.fs.OXIDE.outlet.flow_mol_phase_comp[0, "Liq", "ethylene_glycol"].fix(1e-5*pyunits.mol/pyunits.s)
    m.fs.OXIDE.outlet.temperature.fix(298.15*pyunits.K)
    m.fs.OXIDE.outlet.pressure.fix(1e5*pyunits.Pa)
    
    m.fs.ACID.outlet.flow_mol_phase_comp[0, "Liq", "ethylene_oxide"].fix(1e-5*pyunits.mol/pyunits.s)
    m.fs.ACID.outlet.flow_mol_phase_comp[0, "Liq", "water"].fix(200*pyunits.mol/pyunits.s)
    m.fs.ACID.outlet.flow_mol_phase_comp[0, "Liq", "sulfuric_acid"].fix(0.334*pyunits.mol/pyunits.s)  # calculated from 0.9 wt% SA in stream
    m.fs.ACID.outlet.flow_mol_phase_comp[0, "Liq", "ethylene_glycol"].fix(1e-5*pyunits.mol/pyunits.s)
    m.fs.ACID.outlet.temperature.fix(298.15*pyunits.K)
    m.fs.ACID.outlet.pressure.fix(1e5*pyunits.Pa)

Fixing Unit Model Specifications
--------------------------------

Now that we have fixed our inlet feed conditions, we will now be fixing
the operating conditions for the unit models in the flowsheet. Let us
fix the outlet temperature of H101 to 328.15 K.

.. code:: ipython3

    m.fs.H101.outlet.temperature.fix(328.15*pyunits.K)

For the ``PFR``, we have to define the conversion in terms of ethylene
oxide. Note that the ``PFR`` reaction volume variable (m.fs.R101.volume)
does not need to be defined here since it is internally defined by the
``PFR`` model. We’ll estimate 50% conversion for our initial flowsheet:

.. code:: ipython3

    m.fs.R101.conversion = Var(bounds=(0,1), initialize=0.80, units=pyunits.dimensionless)  # fraction
    
    m.fs.R101.conv_constraint = Constraint(
        expr=m.fs.R101.conversion*m.fs.R101.inlet.
        flow_mol_phase_comp[0, "Liq", "ethylene_oxide"] ==
        (m.fs.R101.inlet.flow_mol_phase_comp[0, "Liq", "ethylene_oxide"] -
         m.fs.R101.outlet.flow_mol_phase_comp[0, "Liq", "ethylene_oxide"]))
    
    for x in m.fs.R101.control_volume.length_domain:
        if x == 0:
            continue
        m.fs.R101.control_volume.properties[0, x].temperature.fix(328.15*pyunits.K) # equal inlet reactor temperature
    
    m.fs.R101.conversion.fix(0.5)
    
    m.fs.R101.length.fix(1*pyunits.m)

As we did not place a specification on reactor duty, the solver may try
positive values to increase the reaction temperature and rate. To
prevent the optimization from diverging, we need to set an upper bound
restricting heat flow to cooling only:

.. code:: ipython3

    m.fs.R101.heat_duty.setub(0*pyunits.J/pyunits.s)  # heat duty is only used for cooling

For initialization, we solve a square problem (degrees of freedom = 0).
Let’s check the degrees of freedom below:

.. code:: ipython3

    print(degrees_of_freedom(m))


.. parsed-literal::

    0


Finally, we need to initialize the each unit operation in sequence to
solve the flowsheet. As in best practice, unit operations are
initialized or solved, and outlet properties are propagated to connected
inlet streams via arc definitions as follows:

.. code:: ipython3

    # Initialize and solve each unit operation
    m.fs.OXIDE.initialize()
    propagate_state(arc=m.fs.s01)
    
    m.fs.ACID.initialize()
    propagate_state(arc=m.fs.s01)
    
    m.fs.M101.initialize()
    propagate_state(arc=m.fs.s03)
    
    m.fs.H101.initialize()
    propagate_state(arc=m.fs.s04)
    
    m.fs.R101.initialize()
    propagate_state(arc=m.fs.s05)
    
    m.fs.PROD.initialize()
    
    # set solver
    solver = get_solver()


.. parsed-literal::

    2023-03-04 01:49:15 [INFO] idaes.init.fs.OXIDE.properties: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.OXIDE.properties: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.OXIDE.properties: Property package initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.OXIDE: Initialization Complete.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.ACID.properties: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.ACID.properties: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.ACID.properties: Property package initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.ACID: Initialization Complete.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101.reagent_feed_state: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101.reagent_feed_state: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101.catalyst_feed_state: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101.catalyst_feed_state: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101.mixed_state: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101.mixed_state: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101.mixed_state: Property package initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.M101: Initialization Complete: optimal - Optimal Solution Found
    2023-03-04 01:49:15 [INFO] idaes.init.fs.H101.control_volume.properties_in: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.H101.control_volume.properties_in: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.H101.control_volume.properties_out: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.H101.control_volume.properties_out: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.H101.control_volume: Initialization Complete
    2023-03-04 01:49:15 [INFO] idaes.init.fs.H101: Initialization Complete: optimal - Optimal Solution Found
    2023-03-04 01:49:15 [INFO] idaes.init.fs.R101.control_volume.properties: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.R101.control_volume.properties: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.R101.control_volume.reactions: Initialization Complete.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.R101.control_volume: Initialization Complete
    2023-03-04 01:49:15 [INFO] idaes.init.fs.R101: Initialization Complete: optimal - Optimal Solution Found
    2023-03-04 01:49:15 [INFO] idaes.init.fs.PROD.properties: Starting initialization
    2023-03-04 01:49:15 [INFO] idaes.init.fs.PROD.properties: Property initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.PROD.properties: Property package initialization: optimal - Optimal Solution Found.
    2023-03-04 01:49:15 [INFO] idaes.init.fs.PROD: Initialization Complete.


.. code:: ipython3

    # Solve the model
    results = solver.solve(m, tee=True)


.. parsed-literal::

    Ipopt 3.13.2: nlp_scaling_method=gradient-based
    tol=1e-06
    max_iter=200
    
    
    ******************************************************************************
    This program contains Ipopt, a library for large-scale nonlinear optimization.
     Ipopt is released as open source code under the Eclipse Public License (EPL).
             For more information visit http://projects.coin-or.org/Ipopt
    
    This version of Ipopt was compiled from source code available at
        https://github.com/IDAES/Ipopt as part of the Institute for the Design of
        Advanced Energy Systems Process Systems Engineering Framework (IDAES PSE
        Framework) Copyright (c) 2018-2019. See https://github.com/IDAES/idaes-pse.
    
    This version of Ipopt was compiled using HSL, a collection of Fortran codes
        for large-scale scientific computation.  All technical papers, sales and
        publicity material resulting from use of the HSL codes within IPOPT must
        contain the following acknowledgement:
            HSL, a collection of Fortran codes for large-scale scientific
            computation. See http://www.hsl.rl.ac.uk.
    ******************************************************************************
    
    This is Ipopt version 3.13.2, running with linear solver ma27.
    
    Number of nonzeros in equality constraint Jacobian...:     1923
    Number of nonzeros in inequality constraint Jacobian.:        0
    Number of nonzeros in Lagrangian Hessian.............:     1323
    
    Total number of variables............................:      608
                         variables with only lower bounds:        0
                    variables with lower and upper bounds:      257
                         variables with only upper bounds:       20
    Total number of equality constraints.................:      608
    Total number of inequality constraints...............:        0
            inequality constraints with only lower bounds:        0
       inequality constraints with lower and upper bounds:        0
            inequality constraints with only upper bounds:        0
    
    iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
       0  0.0000000e+00 1.30e+06 1.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
       1  0.0000000e+00 1.67e+07 5.52e+03  -1.0 1.17e+08    -  2.85e-01 9.90e-01f  1
       2  0.0000000e+00 2.61e+05 6.25e+03  -1.0 1.17e+06    -  8.25e-01 9.90e-01h  1
       3  0.0000000e+00 2.59e+03 3.50e+01  -1.0 1.17e+04    -  9.90e-01 9.90e-01h  1
       4  0.0000000e+00 1.97e+01 3.22e+03  -1.0 1.15e+02    -  9.90e-01 9.92e-01h  1
       5  0.0000000e+00 4.20e-07 4.81e+03  -1.0 8.77e-01    -  9.91e-01 1.00e+00h  1
    Cannot recompute multipliers for feasibility problem.  Error in eq_mult_calculator
    
    Number of Iterations....: 5
    
                                       (scaled)                 (unscaled)
    Objective...............:   0.0000000000000000e+00    0.0000000000000000e+00
    Dual infeasibility......:   1.6686898115291994e+06    1.6686898115291994e+06
    Constraint violation....:   4.1956081986427307e-07    4.1956081986427307e-07
    Complementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00
    Overall NLP error.......:   4.1956081986427307e-07    1.6686898115291994e+06
    
    
    Number of objective function evaluations             = 6
    Number of objective gradient evaluations             = 6
    Number of equality constraint evaluations            = 6
    Number of inequality constraint evaluations          = 0
    Number of equality constraint Jacobian evaluations   = 6
    Number of inequality constraint Jacobian evaluations = 0
    Number of Lagrangian Hessian evaluations             = 5
    Total CPU secs in IPOPT (w/o function evaluations)   =      0.013
    Total CPU secs in NLP function evaluations           =      0.001
    
    EXIT: Optimal Solution Found.


Analyze the Results of the Square Problem
-----------------------------------------

What is the total operating cost?

.. code:: ipython3

    print(f"operating cost = ${value(m.fs.operating_cost)/1e6:0.3f} million per year")


.. parsed-literal::

    operating cost = $43.176 million per year


For this operating cost, what conversion did we achieve of ethylene
oxide to ethylene glycol?

.. code:: ipython3

    m.fs.R101.report()
    
    print()
    print(f"Conversion achieved = {value(m.fs.R101.conversion):.1%}")
    print()
    print(f"Total heat duty required = "
          f"{value(sum(m.fs.R101.heat_duty[0, x] for x in m.fs.R101.control_volume.length_domain))/1e6:0.3f}"
          f" MJ")
    print()
    print(f"Tube area required = {value(m.fs.R101.area):0.3f} m^2")
    print()
    print(f"Tube length required = {value(m.fs.R101.length):0.3f} m")
    print()
    print(f"Tube volume required = {value(m.fs.R101.volume):0.3f} m^3")


.. parsed-literal::

    
    ====================================================================================
    Unit : fs.R101                                                             Time: 0.0
    ------------------------------------------------------------------------------------
        Unit Performance
    
        Variables: 
    
        Key  : Value  : Units      : Fixed : Bounds
        Area : 1.1490 : meter ** 2 : False : (None, None)
    
    ------------------------------------------------------------------------------------
        Stream Table
                                                      Units         Inlet     Outlet  
        Molar Flowrate ('Liq', 'ethylene_oxide')   mole / second     58.000     29.000
        Molar Flowrate ('Liq', 'water')            mole / second     239.60     210.60
        Molar Flowrate ('Liq', 'sulfuric_acid')    mole / second    0.33401    0.33401
        Molar Flowrate ('Liq', 'ethylene_glycol')  mole / second 2.0000e-05     29.000
        Temperature                                       kelvin     328.15     328.15
        Pressure                                          pascal 1.0000e+05 1.0000e+05
    ====================================================================================
    
    Conversion achieved = 50.0%
    
    Total heat duty required = -70.708 MJ
    
    Tube area required = 1.149 m^2
    
    Tube length required = 1.000 m
    
    Tube volume required = 1.149 m^3


Optimizing Ethylene Glycol Production
-------------------------------------

Now that the flowsheet has been squared and solved, we can run a small
optimization problem to minimize our production costs. Suppose we
require at least 200 million pounds/year of ethylene glycol produced and
90% conversion of ethylene oxide, allowing for variable reactor volume
(considering operating/non-capital costs only) and reactor temperature
(heater outlet).

Let us declare our objective function for this problem.

.. code:: ipython3

    m.fs.objective = Objective(expr=m.fs.operating_cost)

Now, we need to add the design constraints and unfix the decision
variables as we had solved a square problem (degrees of freedom = 0)
until now, as well as set bounds for the design variables:

.. code:: ipython3

    m.fs.eg_prod_con = Constraint(expr=m.fs.eg_prod >= 200*pyunits.Mlb/pyunits.yr)  # MM lb/year
    m.fs.R101.conversion.fix(0.90)
    
    m.fs.R101.volume.setlb(0*pyunits.m**3)
    m.fs.R101.volume.setub(pyunits.convert(5000*pyunits.gal, to_units=pyunits.m**3))
    
    m.fs.R101.length.unfix()
    m.fs.R101.length.setlb(0*pyunits.m)
    m.fs.R101.length.setub(5*pyunits.m)
    
    m.fs.H101.outlet.temperature.unfix()
    m.fs.H101.outlet.temperature[0].setlb(328.15*pyunits.K)
    m.fs.H101.outlet.temperature[0].setub(470.45*pyunits.K)  # highest component boiling point (ethylene glycol)
    
    for x in m.fs.R101.control_volume.length_domain:
        if x == 0:
            continue
        m.fs.R101.control_volume.properties[0, x].temperature.unfix()  # allow for temperature change in each finite element

We have now defined the optimization problem and we are now ready to
solve this problem.

.. code:: ipython3

    results = solver.solve(m, tee=True)


.. parsed-literal::

    Ipopt 3.13.2: nlp_scaling_method=gradient-based
    tol=1e-06
    max_iter=200
    
    
    ******************************************************************************
    This program contains Ipopt, a library for large-scale nonlinear optimization.
     Ipopt is released as open source code under the Eclipse Public License (EPL).
             For more information visit http://projects.coin-or.org/Ipopt
    
    This version of Ipopt was compiled from source code available at
        https://github.com/IDAES/Ipopt as part of the Institute for the Design of
        Advanced Energy Systems Process Systems Engineering Framework (IDAES PSE
        Framework) Copyright (c) 2018-2019. See https://github.com/IDAES/idaes-pse.
    
    This version of Ipopt was compiled using HSL, a collection of Fortran codes
        for large-scale scientific computation.  All technical papers, sales and
        publicity material resulting from use of the HSL codes within IPOPT must
        contain the following acknowledgement:
            HSL, a collection of Fortran codes for large-scale scientific
            computation. See http://www.hsl.rl.ac.uk.
    ******************************************************************************
    
    This is Ipopt version 3.13.2, running with linear solver ma27.
    
    Number of nonzeros in equality constraint Jacobian...:     2067
    Number of nonzeros in inequality constraint Jacobian.:        1
    Number of nonzeros in Lagrangian Hessian.............:     1674
    
    Total number of variables............................:      631
                         variables with only lower bounds:        0
                    variables with lower and upper bounds:      280
                         variables with only upper bounds:       21
    Total number of equality constraints.................:      608
    Total number of inequality constraints...............:        1
            inequality constraints with only lower bounds:        1
       inequality constraints with lower and upper bounds:        0
            inequality constraints with only upper bounds:        0
    
    iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
       0  4.3175798e+07 3.66e+06 6.34e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
       1  4.2997780e+07 3.63e+06 1.06e+01  -1.0 2.73e+06    -  7.82e-02 6.75e-03f  1
       2  4.0730124e+07 3.33e+06 1.75e+01  -1.0 2.81e+06    -  1.39e-01 8.38e-02f  1
       3  1.3966480e+07 2.54e+06 6.09e+01  -1.0 2.80e+06    -  4.51e-01 9.90e-01f  1
       4  8.8581953e+06 2.10e+06 4.03e+02  -1.0 1.13e+06    -  8.37e-01 4.68e-01f  1
       5  8.8351099e+06 2.09e+06 1.49e+03  -1.0 8.78e+05    -  5.28e-01 2.73e-03f  1
       6  8.8353948e+06 2.09e+06 2.15e+04  -1.0 6.67e+05    -  9.32e-03 1.07e-04h  1
       7  8.8810310e+06 2.08e+06 2.06e+04  -1.0 1.38e+06    -  6.96e-03 7.17e-03h  1
       8  8.9281010e+06 2.06e+06 3.67e+04  -1.0 1.12e+06    -  1.28e-02 7.38e-03h  1
       9  8.9376715e+06 2.06e+06 1.58e+06  -1.0 6.87e+05    -  5.10e-01 1.45e-03h  1
    iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
      10  1.4123876e+07 4.44e+05 9.53e+06  -1.0 6.95e+05    -  1.76e-01 7.84e-01h  1
      11  1.4231371e+07 4.11e+05 8.84e+06  -1.0 4.86e+05    -  8.93e-01 7.55e-02h  1
      12  1.5542747e+07 5.73e+03 2.72e+06  -1.0 2.39e+06    -  1.86e-01 9.96e-01h  1
      13  1.5546208e+07 1.34e+03 1.34e+06  -1.0 8.40e+05    -  8.89e-01 8.63e-01h  1
      14  1.5545842e+07 2.74e+03 6.38e+05  -1.0 2.16e+06    -  7.32e-01 8.70e-01f  1
      15  1.5545565e+07 2.08e+03 5.06e+05  -1.0 8.20e+02  -4.0 9.91e-01 2.40e-01f  1
      16  1.5544345e+07 8.68e+00 2.21e+05  -1.0 8.77e+02  -4.5 1.00e+00 1.00e+00f  1
      17  1.5542854e+07 6.76e+00 8.02e+04  -1.0 1.12e+03  -5.0 1.00e+00 1.00e+00f  1
      18  1.5541120e+07 9.10e+00 1.75e+04  -1.0 1.33e+03  -5.4 1.00e+00 1.00e+00f  1
      19  1.5539121e+07 1.23e+01 1.10e+04  -1.0 1.73e+03  -5.9 1.00e+00 1.00e+00f  1
    iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
      20  1.5538942e+07 1.14e+01 1.03e+04  -1.0 4.96e+03  -6.4 1.00e+00 8.43e-02f  1
      21  1.5538940e+07 1.14e+01 1.03e+04  -1.0 6.09e+03  -6.9 3.12e-01 8.54e-04f  1
      22  1.5538939e+07 1.12e+01 9.65e+03  -1.0 1.47e+06  -7.3 1.30e-04 1.47e-02f  1
      23  1.5538912e+07 2.70e+04 2.38e+04  -1.0 3.55e+06    -  1.02e-02 1.00e+00f  1
      24  1.5538912e+07 7.20e+00 2.33e+02  -1.0 4.70e+03  -7.8 9.67e-01 1.00e+00h  1
      25  1.5538912e+07 5.09e+03 8.82e+03  -1.0 4.75e+06    -  5.06e-02 4.03e-01h  1
      26  1.5538912e+07 8.70e+04 7.18e+03  -1.0 5.74e+07    -  4.25e-02 1.89e-01h  2
      27  1.5538912e+07 3.58e+05 4.06e+03  -1.0 4.79e+07    -  3.66e-01 4.46e-01h  1
      28  1.5538912e+07 4.24e+05 3.72e+02  -1.0 2.23e+07    -  1.00e+00 1.00e+00h  1
      29  1.5538912e+07 2.04e+05 8.46e+01  -1.0 1.87e+07    -  5.16e-01 1.00e+00f  1
    iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
      30  1.5538912e+07 1.59e+05 3.47e+01  -1.0 1.59e+07    -  9.86e-01 1.00e+00h  1
      31  1.5538912e+07 1.24e+05 2.08e+01  -1.0 9.46e+06    -  2.25e-01 2.38e-01H  1
      32  1.5538912e+07 5.12e+04 8.85e+00  -1.0 8.55e+06    -  1.00e+00 1.00e+00f  1
      33  1.5538912e+07 6.37e+03 2.36e+00  -1.0 2.94e+06    -  1.00e+00 1.00e+00h  1
      34  1.5538912e+07 1.11e+03 4.70e-01  -1.0 1.25e+06    -  1.00e+00 1.00e+00h  1
      35  1.5538912e+07 3.25e+00 3.62e-02  -1.7 6.61e+04    -  1.00e+00 1.00e+00h  1
      36  1.5538912e+07 6.41e-03 5.57e-04  -3.8 3.02e+03    -  1.00e+00 1.00e+00h  1
      37  1.5538912e+07 1.74e-05 2.64e-07  -7.0 1.58e+02    -  1.00e+00 1.00e+00h  1
    
    Number of Iterations....: 37
    
                                       (scaled)                 (unscaled)
    Objective...............:   1.5538911764822546e+07    1.5538911764822546e+07
    Dual infeasibility......:   2.6405877696228375e-07    2.6405877696228375e-07
    Constraint violation....:   4.5634806156158447e-07    1.7434358596801758e-05
    Complementarity.........:   9.4799477164670495e-08    9.4799477164670495e-08
    Overall NLP error.......:   4.5634806156158447e-07    1.7434358596801758e-05
    
    
    Number of objective function evaluations             = 40
    Number of objective gradient evaluations             = 38
    Number of equality constraint evaluations            = 40
    Number of inequality constraint evaluations          = 40
    Number of equality constraint Jacobian evaluations   = 38
    Number of inequality constraint Jacobian evaluations = 38
    Number of Lagrangian Hessian evaluations             = 37
    Total CPU secs in IPOPT (w/o function evaluations)   =      0.106
    Total CPU secs in NLP function evaluations           =      0.012
    
    EXIT: Optimal Solution Found.


.. code:: ipython3

    print(f"operating cost = ${value(m.fs.operating_cost)/1e6:0.3f} million per year")
    
    print()
    print('Heater results')
    
    m.fs.H101.report()
    
    print()
    print('PFR reactor results')
    
    m.fs.R101.report()


.. parsed-literal::

    operating cost = $15.539 million per year
    
    Heater results
    
    ====================================================================================
    Unit : fs.H101                                                             Time: 0.0
    ------------------------------------------------------------------------------------
        Unit Performance
    
        Variables: 
    
        Key       : Value  : Units : Fixed : Bounds
        Heat Duty : 699.26 :  watt : False : (None, None)
    
    ------------------------------------------------------------------------------------
        Stream Table
                                                      Units         Inlet     Outlet  
        Molar Flowrate ('Liq', 'ethylene_oxide')   mole / second     58.000     58.000
        Molar Flowrate ('Liq', 'water')            mole / second     239.60     239.60
        Molar Flowrate ('Liq', 'sulfuric_acid')    mole / second    0.33401    0.33401
        Molar Flowrate ('Liq', 'ethylene_glycol')  mole / second 2.0000e-05 2.0000e-05
        Temperature                                       kelvin     298.15     328.15
        Pressure                                          pascal 1.0000e+05 1.0000e+05
    ====================================================================================
    
    PFR reactor results
    
    ====================================================================================
    Unit : fs.R101                                                             Time: 0.0
    ------------------------------------------------------------------------------------
        Unit Performance
    
        Variables: 
    
        Key  : Value  : Units      : Fixed : Bounds
        Area : 2.7874 : meter ** 2 : False : (None, None)
    
    ------------------------------------------------------------------------------------
        Stream Table
                                                      Units         Inlet     Outlet  
        Molar Flowrate ('Liq', 'ethylene_oxide')   mole / second     58.000     5.8000
        Molar Flowrate ('Liq', 'water')            mole / second     239.60     187.40
        Molar Flowrate ('Liq', 'sulfuric_acid')    mole / second    0.33401    0.33401
        Molar Flowrate ('Liq', 'ethylene_glycol')  mole / second 2.0000e-05     52.200
        Temperature                                       kelvin     328.15     450.00
        Pressure                                          pascal 1.0000e+05 1.0000e+05
    ====================================================================================


Display optimal values for the decision variables and design variables:

.. code:: ipython3

    print('Optimal Values')
    print()
    
    print(f"H101 outlet temperature = {value(m.fs.H101.outlet.temperature[0]):0.3f} K")
    
    print()
    print('Total heat duty required = ', value(sum(m.fs.R101.heat_duty[0, x]
                                                         for x in m.fs.R101.control_volume.length_domain))/1e6, 'MJ')
    print()
    print(f"Tube area required = {value(m.fs.R101.area):0.3f} m^2")
    
    print()
    print(f"Tube length required = {value(m.fs.R101.length):0.3f} m")
    
    print()
    print(f"Assuming a 20% design factor for reactor volume,"
          f"total CSTR volume required = {value(1.2*m.fs.R101.volume):0.3f}"
          f" m^3 = {value(pyunits.convert(1.2*m.fs.R101.volume, to_units=pyunits.gal)):0.3f} gal")
    
    print()
    print(f"Ethylene glycol produced = {value(m.fs.eg_prod):0.3f} MM lb/year")
    
    print()
    print(f"Conversion achieved = {value(m.fs.R101.conversion):.1%}")


.. parsed-literal::

    Optimal Values
    
    H101 outlet temperature = 328.150 K
    
    Total heat duty required =  -25.443005245978295 MJ
    
    Tube area required = 2.787 m^2
    
    Tube length required = 5.000 m
    
    Assuming a 20% design factor for reactor volume,total CSTR volume required = 16.725 m^3 = 4418.149 gal
    
    Ethylene glycol produced = 225.415 MM lb/year
    
    Conversion achieved = 90.0%


