Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

+--------+-----------+-----------+------------+---+
|        | tag1      | tag2      | tag3       | … |
+========+===========+===========+============+===+
| index1 | data(1,1) | data(1,2) | data(1, 3) | … |
+--------+-----------+-----------+------------+---+
| index2 | data(2,1) | data(2,2) | data(2, 3) | … |
+--------+-----------+-----------+------------+---+
| …      | …         | …         | …          | … |
+--------+-----------+-----------+------------+---+

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

|       \| \| \| \| \|

\|——-|— —————|—————|——————-|—————————————————–\| \| tag1 \| model
reference 1 \| description 1 \| unit of measure 1 \| Additional
comments, additional columns are ignored \| \| tag2 \| model reference 2
\| description 2 \| unit of measure 2 \| … \| \| tag3 \| model reference
3 \| description 3 \| unit of measure 3 \| … \| \| … \| … \| … \| … \| …
\|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
“data_plot_book.pdf.”

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.power_generation.properties.flue_gas_ideal import FlueGasParameterBlock
    from idaes.generic_models.properties import iapws95
    from idaes.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        DeltaTMethod
    )
    import pyomo.environ as pyo

.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(default={"dynamic": False})
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(default={
            "side_1_property_package": m.fs.prop_water,
            "side_2_property_package": m.fs.prop_fluegas,
            "has_pressure_change": True,
            "has_holdup": False,
            "delta_T_method": DeltaTMethod.counterCurrent,
            "tube_arrangement": TubeArrangement.inLine,
            "side_1_water_phase": "Liq",
            "has_radiation": False
        }
    )

.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = iapws95.htpx(563.706, 2.5449e7)
    
    m.fs.econ.side_1_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.side_1_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.side_1_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.side_2.properties_in[0].flow_mol_comp[c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.side_2_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.side_2_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.side_1_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.side_1_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.side_1_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.side_2_inlet.flow_mol_comp[0, "H2O"].value,
                "CO2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "CO2"].value,
                "N2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "N2"].value,
                "O2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "O2"].value,
                "NO": m.fs.econ.side_2_inlet.flow_mol_comp[0, "NO"].value,
                "SO2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "SO2"].value,
            },
            "temperature": m.fs.econ.side_2_inlet.temperature[0].value,
            "pressure": m.fs.econ.side_2_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ.side_1: Initialization Complete
    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ.side_2.properties_in: Initialisation Complete, optimal - Optimal Solution Found.
    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ.side_2.properties_out: Initialisation Complete, optimal - Optimal Solution Found.
    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ.side_2.properties_out: fs.econ.side_2.properties_out State Released.
    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ.side_2: Initialization Complete
    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ: fs.econ Initialisation Step 1 Complete.
    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ.side_2.properties_in: fs.econ.side_2.properties_in State Released.
    2020-10-08 18:29:43 [INFO] idaes.init.fs.econ: fs.econ Initialisation Complete.


3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()
    m.fs.econ.LMTD.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.  
    import idaes.core.util.tables as ta
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # this is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.side_1_inlet,
            "ECON_OUT": m.fs.econ.side_1_outlet,
            "FG_2_ECON": m.fs.econ.side_2_inlet,
            "FG_2_AIRPH": m.fs.econ.side_2_outlet,
        },
        sort=True,
    )
    
    # The next function converts the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ta.tag_state_quantities(
        blocks=state_dict, 
        attributes=(
            "flow_mass", 
            "flow_mol", 
            "enth_mol", 
            "temperature", 
            "pressure", 
            ("flow_mol_comp", "O2"),
            ("flow_mol_comp", "NO"),
            ("flow_mol_comp", "N2"),
            ("flow_mol_comp", "SO2"),
            ("flow_mol_comp", "CO2"),
            ("flow_mol_comp", "H2O"),
        ), 
        labels=("_Fm", "_F", "_h", "_T", "_P", "_F[O2]", "_F[NO]", "_F[N2]", "_F[SO2]", "_F[CO2]", "_F[H2O]"),
    )
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags["ECON_Q"] = m.fs.econ.heat_duty[0]

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.misc import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tags={"subtitle":"Initialized Model"})
        s = svg_tag(svg=s, tags=recon_tags, outfile="econ_init.svg")

.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.side_2.properties_in[0].flow_mol_comp[c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.side_1_inlet.unfix()
    m.fs.econ.side_2_inlet.unfix()
    m.fs.econ.side_1_outlet.unfix()
    m.fs.econ.side_2_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t])
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.162201360626805
    1 -- optimal, objective: 0.8197916348655777
    2 -- optimal, objective: 1.4704841795757688
    3 -- optimal, objective: 1.1898903678089334
    4 -- optimal, objective: 6.266902064585218
    5 -- optimal, objective: 2.353798975733356
    6 -- optimal, objective: 0.5232362409291014
    7 -- optimal, objective: 1.0234347889957236
    8 -- optimal, objective: 1.6923646000432966
    9 -- optimal, objective: 5.200181621761002
    10 -- optimal, objective: 2.025678883244262
    11 -- optimal, objective: 1.3755282573108523
    12 -- optimal, objective: 1.804041195022773
    13 -- optimal, objective: 1.082045272199176
    14 -- optimal, objective: 2.8725508346784707
    15 -- optimal, objective: 4.679431401768908
    16 -- optimal, objective: 2.528546248998911
    17 -- optimal, objective: 3.419056606898886
    18 -- optimal, objective: 0.6733248046041344
    19 -- optimal, objective: 1.3191174229584783
    20 -- optimal, objective: 2.591126369762912
    21 -- optimal, objective: 0.7284969800023136
    22 -- optimal, objective: 3.0960880080285285
    23 -- optimal, objective: 8.046882712386495
    24 -- optimal, objective: 9.434438819028902
    25 -- optimal, objective: 2.908666060552151
    26 -- optimal, objective: 5.764854776323216
    27 -- optimal, objective: 1.5869850001197114
    28 -- optimal, objective: 0.984970687035975
    29 -- optimal, objective: 5.420696622705057
    30 -- optimal, objective: 0.1606657874634176
    31 -- optimal, objective: 1.9662633227547468
    32 -- optimal, objective: 4.631928468438901
    33 -- optimal, objective: 0.7898326457669669
    34 -- optimal, objective: 4.935316816207466
    35 -- optimal, objective: 2.7822175536741494
    36 -- optimal, objective: 3.793604211882937
    37 -- optimal, objective: 7.399694410586056
    38 -- optimal, objective: 1.823493188904753
    39 -- optimal, objective: 8.123278203552593
    40 -- optimal, objective: 2.466989330256696
    41 -- optimal, objective: 2.059053712273176
    42 -- optimal, objective: 4.8248900459123005
    43 -- optimal, objective: 2.9053626799280687
    44 -- optimal, objective: 1.2572997144470626
    45 -- optimal, objective: 2.7626453809391953
    46 -- optimal, objective: 3.9106046062442417
    47 -- optimal, objective: 0.36384547188943156
    48 -- optimal, objective: 6.4821230867244655
    49 -- optimal, objective: 0.8862884524239355
    50 -- optimal, objective: 0.35333788962392954
    51 -- optimal, objective: 0.6741934666897321
    52 -- optimal, objective: 1.446566598089188
    53 -- optimal, objective: 2.365692115533386
    54 -- optimal, objective: 1.4292836233967594
    55 -- optimal, objective: 11.608835808833685
    56 -- optimal, objective: 2.584558536493552
    57 -- optimal, objective: 2.2280318353692903
    58 -- optimal, objective: 2.49539396555218
    59 -- optimal, objective: 1.6472887590069913
    60 -- optimal, objective: 8.024825566331401
    61 -- optimal, objective: 5.943553444690272
    62 -- optimal, objective: 2.335786062559982
    63 -- optimal, objective: 4.385139025177347
    64 -- optimal, objective: 0.5607805981598083
    65 -- optimal, objective: 2.17684713563556
    66 -- optimal, objective: 2.823283673697928
    67 -- optimal, objective: 4.3969064436584295
    68 -- optimal, objective: 3.3918559300376505
    69 -- optimal, objective: 0.6148795243220563
    70 -- optimal, objective: 0.3708280914479005
    71 -- optimal, objective: 0.8762641865695853
    72 -- optimal, objective: 3.0086342942362587
    73 -- optimal, objective: 6.1782756837045545
    74 -- optimal, objective: 2.4515957154908397
    75 -- optimal, objective: 8.97473642570102
    76 -- optimal, objective: 1.7706655882254887
    77 -- optimal, objective: 3.1265189714763224
    78 -- optimal, objective: 5.205301238989008
    79 -- optimal, objective: 4.769597864830058
    80 -- optimal, objective: 4.816644746436776
    81 -- optimal, objective: 0.653281283541457
    82 -- optimal, objective: 2.4965181358360344
    83 -- optimal, objective: 0.8032343482262086
    84 -- optimal, objective: 0.3628249337525187
    85 -- optimal, objective: 1.523823819480629
    86 -- optimal, objective: 3.865787830956067
    87 -- optimal, objective: 1.722274966871554
    88 -- optimal, objective: 3.953876969181431
    89 -- optimal, objective: 1.6523612426748602
    90 -- optimal, objective: 3.351063841683783
    91 -- optimal, objective: 1.2093955196393413
    92 -- optimal, objective: 1.5787045321363247
    93 -- optimal, objective: 3.410419301472484
    94 -- optimal, objective: 1.2638978913500678
    95 -- optimal, objective: 3.2950093864132315
    96 -- optimal, objective: 1.530697826703644
    97 -- optimal, objective: 2.0576162766855504
    98 -- optimal, objective: 1.7332102521609256
    99 -- optimal, objective: 4.588249738737969
    100 -- optimal, objective: 0.9295175448471505
    101 -- optimal, objective: 1.1035561284196362
    102 -- optimal, objective: 0.005402403281198675
    103 -- optimal, objective: 4.030350825817915
    104 -- optimal, objective: 2.597768847187362
    105 -- optimal, objective: 3.7186572151823736
    106 -- optimal, objective: 2.2200012303835615
    107 -- optimal, objective: 1.7361821672875608
    108 -- optimal, objective: 1.782794817352385
    109 -- optimal, objective: 0.8012022277040005
    110 -- optimal, objective: 0.4890697265296753
    111 -- optimal, objective: 4.625396349830712
    112 -- optimal, objective: 4.07305004423315
    113 -- optimal, objective: 4.984164789951537
    114 -- optimal, objective: 4.500918344081718
    115 -- optimal, objective: 0.8012413198265776
    116 -- optimal, objective: 2.687543401764702
    117 -- optimal, objective: 6.864934379080615
    118 -- optimal, objective: 3.0375805861817073
    119 -- optimal, objective: 2.4941088890247234
    120 -- optimal, objective: 0.4608335178548384
    121 -- optimal, objective: 0.0444713315916445
    122 -- optimal, objective: 1.909182664513564
    123 -- optimal, objective: 4.153927862805064
    124 -- optimal, objective: 5.635821162573207
    125 -- optimal, objective: 4.7224485847294915
    126 -- optimal, objective: 4.838421311326242
    127 -- optimal, objective: 2.8953598470298147
    128 -- optimal, objective: 0.17007028011336606
    129 -- optimal, objective: 0.9837813189594365
    130 -- optimal, objective: 8.052242413116765
    131 -- optimal, objective: 6.2603495300987735
    132 -- optimal, objective: 2.5726387350162447
    133 -- optimal, objective: 3.73323064910812
    134 -- optimal, objective: 0.34006496250117074
    135 -- optimal, objective: 3.6032792688193527
    136 -- optimal, objective: 2.5015728490600564
    137 -- optimal, objective: 0.3964133950014042
    138 -- optimal, objective: 0.1414040424714738
    139 -- optimal, objective: 8.317240586428646
    140 -- optimal, objective: 5.424448709520704
    141 -- optimal, objective: 2.8357713483632234
    142 -- optimal, objective: 1.5375770466936083
    143 -- optimal, objective: 3.6241716127443615
    144 -- optimal, objective: 4.9547317054453
    145 -- optimal, objective: 0.5851578341559454
    146 -- optimal, objective: 4.899534932815152
    147 -- optimal, objective: 3.682266173635671
    148 -- optimal, objective: 2.121107969962811
    149 -- optimal, objective: 1.719942839659069
    150 -- optimal, objective: 3.3189214980332933
    151 -- optimal, objective: 0.36851885526623
    152 -- optimal, objective: 1.9488105776159723
    153 -- optimal, objective: 2.6747870424161957
    154 -- optimal, objective: 7.58565660584803
    155 -- optimal, objective: 3.395738722518671
    156 -- optimal, objective: 4.149600126698334
    157 -- optimal, objective: 1.0001276150025051
    158 -- optimal, objective: 3.0644614255860803
    159 -- optimal, objective: 5.0139923079556175
    160 -- optimal, objective: 3.83986001722089
    161 -- optimal, objective: 1.6576814935989237
    162 -- optimal, objective: 0.41178378891993106
    163 -- optimal, objective: 2.0406846027880214
    164 -- optimal, objective: 2.0029977728129325
    165 -- optimal, objective: 2.5114799236149494
    166 -- optimal, objective: 0.4825891465216597
    167 -- optimal, objective: 3.888976657626192
    168 -- optimal, objective: 1.076946530824914
    169 -- optimal, objective: 2.499193200876676
    170 -- optimal, objective: 1.8451901507026043
    171 -- optimal, objective: 4.516240233107765
    172 -- optimal, objective: 3.7259498522241534
    173 -- optimal, objective: 1.9205975302203506
    174 -- optimal, objective: 1.6040476837711675
    175 -- optimal, objective: 0.3297073490067156
    176 -- optimal, objective: 3.1773026407606726
    177 -- optimal, objective: 4.892210628679248
    178 -- optimal, objective: 1.7344424108100656
    179 -- optimal, objective: 2.0930393921890373
    180 -- optimal, objective: 1.9821792611906703
    181 -- optimal, objective: 3.0950130851162556
    182 -- optimal, objective: 2.562542928308214
    183 -- optimal, objective: 6.469840016661062
    184 -- optimal, objective: 2.0674756021956617
    185 -- optimal, objective: 2.3845462972645164
    186 -- optimal, objective: 1.511966747607889
    187 -- optimal, objective: 3.6253762909980813
    188 -- optimal, objective: 0.983648966329757
    189 -- optimal, objective: 1.917402129522526
    190 -- optimal, objective: 1.0200049678523708
    191 -- optimal, objective: 1.811114748637622
    192 -- optimal, objective: 10.407007486649146
    193 -- optimal, objective: 5.725212636472546
    194 -- optimal, objective: 6.585121023533319
    195 -- optimal, objective: 1.1403803946151592
    196 -- optimal, objective: 4.636496073472313
    197 -- optimal, objective: 3.9217711869994103
    198 -- optimal, objective: 1.0045702656827695
    199 -- optimal, objective: 2.4182154805459217
    200 -- optimal, objective: 2.9243580215265075
    201 -- optimal, objective: 2.9689758379686633
    202 -- optimal, objective: 2.615284972301557
    203 -- optimal, objective: 2.4914091180308664
    204 -- optimal, objective: 1.7943475942577947
    205 -- optimal, objective: 5.708286126989026
    206 -- optimal, objective: 2.4056024845433246
    207 -- optimal, objective: 0.9383323510764549
    208 -- optimal, objective: 4.7966629915068255
    209 -- optimal, objective: 0.5067734258626391
    210 -- optimal, objective: 2.18908845788361
    211 -- optimal, objective: 3.2162783129697528
    212 -- optimal, objective: 0.07969866183078671
    213 -- optimal, objective: 0.39071669881268717
    214 -- optimal, objective: 4.024001493294811
    215 -- optimal, objective: 3.5942799491735613
    216 -- optimal, objective: 1.6777857029028593
    217 -- optimal, objective: 4.848031703923904
    218 -- optimal, objective: 0.48853441088515154
    219 -- optimal, objective: 12.374570705038185
    220 -- optimal, objective: 1.428411060496607
    221 -- optimal, objective: 1.8180427493589295
    222 -- optimal, objective: 0.48500850265305234
    223 -- optimal, objective: 2.506785180656373
    224 -- optimal, objective: 1.3976812984152938
    225 -- optimal, objective: 0.9031717605985257
    226 -- optimal, objective: 0.7285447496524818
    227 -- optimal, objective: 2.470391275052255
    228 -- optimal, objective: 2.675134784707765
    229 -- optimal, objective: 3.325674612581546
    230 -- optimal, objective: 2.5990372980399843
    231 -- optimal, objective: 4.83760577814937
    232 -- optimal, objective: 1.132923488341594
    233 -- optimal, objective: 1.639839943128601
    234 -- optimal, objective: 3.0089833505496966
    235 -- optimal, objective: 1.4124043086038391
    236 -- optimal, objective: 5.771998515376797
    237 -- optimal, objective: 0.1493890601568094
    238 -- optimal, objective: 1.2057474878057748
    239 -- optimal, objective: 1.7168126471501945
    240 -- optimal, objective: 4.602217912756757
    241 -- optimal, objective: 2.1236286863590497
    242 -- optimal, objective: 2.5315899941166378
    243 -- optimal, objective: 1.7031408430137671
    244 -- optimal, objective: 2.2177940017210505
    245 -- optimal, objective: 0.6465659506433724
    246 -- optimal, objective: 1.291636517564751
    247 -- optimal, objective: 7.79025842117088
    248 -- optimal, objective: 1.060558078675777
    249 -- optimal, objective: 1.1515044674820722


.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function. Plot terminated.


