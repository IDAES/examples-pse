Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.core.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

====== ========= ========= ========== =
\      tag1      tag2      tag3       …
====== ========= ========= ========== =
index1 data(1,1) data(1,2) data(1, 3) …
index2 data(2,1) data(2,2) data(2, 3) …
…      …         …         …          …
====== ========= ========= ========== =

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

|       \| \| \| \| \|

\|——-|— —————|—————|——————-|—————————————————–\| \| tag1 \| model
reference 1 \| description 1 \| unit of measure 1 \| Additional
comments, additional columns are ignored \| \| tag2 \| model reference 2
\| description 2 \| unit of measure 2 \| … \| \| tag3 \| model reference
3 \| description 3 \| unit of measure 3 \| … \| \| … \| … \| … \| … \| …
\|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
“data_plot_book.pdf.”

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.models_extra.power_generation.properties.flue_gas_ideal import FlueGasParameterBlock
    from idaes.models.properties import iapws95
    from idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        HeatExchangerFlowPattern
    )
    import pyomo.environ as pyo

.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(dynamic=False)
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(
        cold_side={"property_package": m.fs.prop_water,
                   "has_pressure_change": True},
        hot_side={"property_package": m.fs.prop_fluegas,
                  "has_pressure_change": True},
        has_holdup=False,
        flow_pattern=HeatExchangerFlowPattern.countercurrent,
        tube_arrangement=TubeArrangement.inLine,
        cold_side_water_phase="Liq",
        has_radiation=False
    )

.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = pyo.value(iapws95.htpx(563.706*pyo.units.K, 2.5449e7*pyo.units.Pa))
    
    m.fs.econ.cold_side_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.cold_side_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.cold_side_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.hot_side.properties_in[0].flow_mol_comp[c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.hot_side_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.hot_side_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.cold_side_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.cold_side_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.cold_side_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "H2O"].value,
                "CO2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "CO2"].value,
                "N2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "N2"].value,
                "O2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "O2"].value,
                "NO": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "NO"].value,
                "SO2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "SO2"].value,
            },
            "temperature": m.fs.econ.hot_side_inlet.temperature[0].value,
            "pressure": m.fs.econ.hot_side_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ.cold_side: Initialization Complete
    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ.hot_side.properties_in: Initialisation Complete, optimal - Optimal Solution Found.
    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ.hot_side.properties_out: Initialisation Complete, optimal - Optimal Solution Found.
    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ.hot_side.properties_out: fs.econ.hot_side.properties_out State Released.
    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ.hot_side: Initialization Complete
    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ: fs.econ Initialisation Step 1 Complete.
    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ.hot_side.properties_in: fs.econ.hot_side.properties_in State Released.
    2022-12-07 19:00:23 [INFO] idaes.init.fs.econ: fs.econ Initialisation Complete.


3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.cold_side.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.cold_side.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.cold_side.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.cold_side.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.cold_side.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.cold_side.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.hot_side.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.hot_side.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.hot_side.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.hot_side.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.hot_side.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.hot_side.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.
    import idaes.core.util.tables as ta
    from idaes.core.util.tags import ModelTagGroup
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # this is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.cold_side_inlet,
            "ECON_OUT": m.fs.econ.cold_side_outlet,
            "FG_2_ECON": m.fs.econ.hot_side_inlet,
            "FG_2_AIRPH": m.fs.econ.hot_side_outlet,
        },
        sort=True,
    )
    
    # The next function converts the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ModelTagGroup()
    
    prop_dict = {
        "flow_mass": "_Fm",
        "flow_mol": "_F",
        "enth_mol": "_h",
        "temperature": "_T",
        "pressure": "_P",
    }
    comp_list = ["O2", "NO", "N2", "SO2", "CO2", "H2O"]
    
    for state, block in state_dict.items():
        for prop, suffix in prop_dict.items():
            comp = getattr(block, prop)
            recon_tags.add(expr=comp, name=state+suffix, format_string="{:.3f}")
        # Add tags for molar flow rates of each component
        for j in comp_list:
            # Not all components appear in all streams
            try:
                comp = block.flow_mol_comp[j]
                recon_tags.add(expr=comp, name=f"{state}_F[{j}]", format_string="{:.3f}")
            except KeyError:
                pass
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags.add(expr=m.fs.econ.heat_duty[0], name="ECON_Q", format_string="{:.3f}")

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.tags import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tag_group=recon_tags, outfile="econ_init.svg")

.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.hot_side.properties_in[0].flow_mol_comp[c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.cold_side_inlet.unfix()
    m.fs.econ.hot_side_inlet.unfix()
    m.fs.econ.cold_side_outlet.unfix()
    m.fs.econ.hot_side_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t].expression)
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.1622331890498727
    1 -- optimal, objective: 0.8197864499890336
    2 -- optimal, objective: 1.4705020498259085
    3 -- optimal, objective: 1.1898579077048663
    4 -- optimal, objective: 6.266862831652866
    5 -- optimal, objective: 2.353837799417015
    6 -- optimal, objective: 0.5232270065114805
    7 -- optimal, objective: 1.0234628569513593
    8 -- optimal, objective: 1.69239772085162
    9 -- optimal, objective: 5.200192745852323
    10 -- optimal, objective: 2.025697843022416
    11 -- optimal, objective: 1.3755022829202792
    12 -- optimal, objective: 1.8040084546445476
    13 -- optimal, objective: 1.0820697968576516
    14 -- optimal, objective: 2.872565777305582
    15 -- optimal, objective: 4.679377996142952
    16 -- optimal, objective: 2.528568205492202
    17 -- optimal, objective: 3.419105635591257
    18 -- optimal, objective: 0.6733502043659162
    19 -- optimal, objective: 1.3191453351995384
    20 -- optimal, objective: 2.591078951894161
    21 -- optimal, objective: 0.7284892511624449
    22 -- optimal, objective: 3.0961354376474013
    23 -- optimal, objective: 8.046924273772053
    24 -- optimal, objective: 9.434482098827107
    25 -- optimal, objective: 2.908715618274769
    26 -- optimal, objective: 5.764858402612371
    27 -- optimal, objective: 1.5869947333050478
    28 -- optimal, objective: 0.9849858467552118
    29 -- optimal, objective: 5.420724866466438
    30 -- optimal, objective: 0.15987314723601984
    31 -- optimal, objective: 1.9662745455935222
    32 -- optimal, objective: 4.631981600955148
    33 -- optimal, objective: 0.7898383615771294
    34 -- optimal, objective: 4.9353180306590145
    35 -- optimal, objective: 2.782272921405284
    36 -- optimal, objective: 3.7935361234624745
    37 -- optimal, objective: 7.399744163756904
    38 -- optimal, objective: 1.8234832495958408
    39 -- optimal, objective: 8.12319775531644
    40 -- optimal, objective: 2.4669673741726554
    41 -- optimal, objective: 2.058995669731831
    42 -- optimal, objective: 4.824845773329286
    43 -- optimal, objective: 2.9053545109949046
    44 -- optimal, objective: 1.2573498031482857
    45 -- optimal, objective: 2.7626595146393824
    46 -- optimal, objective: 3.910541416626472
    47 -- optimal, objective: 0.3638539213531799
    48 -- optimal, objective: 6.482045124670575
    49 -- optimal, objective: 0.8862853314576071
    50 -- optimal, objective: 0.3533301795603335
    51 -- optimal, objective: 0.6741716772663022
    52 -- optimal, objective: 1.4465656566076073
    53 -- optimal, objective: 2.365722448400687
    54 -- optimal, objective: 1.4293144956083155
    55 -- optimal, objective: 11.608899577383479
    56 -- optimal, objective: 2.5845585147163392
    57 -- optimal, objective: 2.228041896062172
    58 -- optimal, objective: 2.495366757353478
    59 -- optimal, objective: 1.6473143733651079
    60 -- optimal, objective: 8.024762155447853
    61 -- optimal, objective: 5.943580608761364
    62 -- optimal, objective: 2.3358112651340805
    63 -- optimal, objective: 4.385134901100444
    64 -- optimal, objective: 0.5607991758544013
    65 -- optimal, objective: 2.1768860904784026
    66 -- optimal, objective: 2.8233305625189353
    67 -- optimal, objective: 4.396916342718599
    68 -- optimal, objective: 3.3918215001740997
    69 -- optimal, objective: 0.6148617687094012
    70 -- optimal, objective: 0.3708295031059488
    71 -- optimal, objective: 0.8762410268086774
    72 -- optimal, objective: 3.008619356231839
    73 -- optimal, objective: 6.1783102528736
    74 -- optimal, objective: 2.4515738657466897
    75 -- optimal, objective: 8.974808392535532
    76 -- optimal, objective: 1.770701321328801
    77 -- optimal, objective: 3.1265504086291784
    78 -- optimal, objective: 5.203564818159466
    79 -- optimal, objective: 4.769633196274002
    80 -- optimal, objective: 4.816640912308064
    81 -- optimal, objective: 0.6532705965567928
    82 -- optimal, objective: 2.4965339056024147
    83 -- optimal, objective: 0.803240379321804
    84 -- optimal, objective: 0.36284361632594453
    85 -- optimal, objective: 1.5238517213116318
    86 -- optimal, objective: 3.86574891719081
    87 -- optimal, objective: 1.7222638616760835
    88 -- optimal, objective: 3.9538701224262245
    89 -- optimal, objective: 1.652363315868664
    90 -- optimal, objective: 3.351117802162063
    91 -- optimal, objective: 1.2094064053343998
    92 -- optimal, objective: 1.5787039265702387
    93 -- optimal, objective: 3.4104161322803037
    94 -- optimal, objective: 1.2638744445651962
    95 -- optimal, objective: 3.2950269700522323
    96 -- optimal, objective: 1.5307297912769973
    97 -- optimal, objective: 2.057619546085226
    98 -- optimal, objective: 1.733201919869831
    99 -- optimal, objective: 4.588294007037136
    100 -- optimal, objective: 0.9292950798611841
    101 -- optimal, objective: 1.1035420871623736
    102 -- optimal, objective: 0.005403430398351565
    103 -- optimal, objective: 4.0303796839931785
    104 -- optimal, objective: 2.5977953040666937
    105 -- optimal, objective: 3.718627904476453
    106 -- optimal, objective: 2.220011645610566
    107 -- optimal, objective: 1.736150100935714
    108 -- optimal, objective: 1.7827888202877222
    109 -- optimal, objective: 0.8012255957981186
    110 -- optimal, objective: 0.48908830991578595
    111 -- optimal, objective: 4.62546829042185
    112 -- optimal, objective: 4.073067561398429
    113 -- optimal, objective: 4.984142249931015
    114 -- optimal, objective: 4.500896627466661
    115 -- optimal, objective: 0.8012366493659524
    116 -- optimal, objective: 2.6875597539254614
    117 -- optimal, objective: 6.864914207638013
    118 -- optimal, objective: 3.03753834834472
    119 -- optimal, objective: 2.494092682573101
    120 -- optimal, objective: 0.46083128411318375
    121 -- optimal, objective: 0.04447270311554718
    122 -- optimal, objective: 1.9092249228761486
    123 -- optimal, objective: 4.153943649844314
    124 -- optimal, objective: 5.635795985484611
    125 -- optimal, objective: 4.722375449559217
    126 -- optimal, objective: 4.837800008333995
    127 -- optimal, objective: 2.8954190363542667
    128 -- optimal, objective: 0.17007418111840517
    129 -- optimal, objective: 0.9837965852424605
    130 -- optimal, objective: 8.052261850607364
    131 -- optimal, objective: 6.2603000199957695
    132 -- optimal, objective: 2.5725785456392454
    133 -- optimal, objective: 3.733186985591762
    134 -- optimal, objective: 0.34006123622223705
    135 -- optimal, objective: 3.603334225872326
    136 -- optimal, objective: 2.5015732182201598
    137 -- optimal, objective: 0.396399757649974
    138 -- optimal, objective: 0.14140324820958952
    139 -- optimal, objective: 8.317346638087342
    140 -- optimal, objective: 5.424422727514874
    141 -- optimal, objective: 2.8357278805421435
    142 -- optimal, objective: 1.5376133193669768
    143 -- optimal, objective: 3.624208474551768
    144 -- optimal, objective: 4.95468987698991
    145 -- optimal, objective: 0.5851604096299975
    146 -- optimal, objective: 4.899590933174407
    147 -- optimal, objective: 3.682270094664583
    148 -- optimal, objective: 2.1210809671683895
    149 -- optimal, objective: 1.7199975728804051
    150 -- optimal, objective: 3.318908100409923
    151 -- optimal, objective: 0.36850247207855763
    152 -- optimal, objective: 1.9488439097577899
    153 -- optimal, objective: 2.6747587962823696
    154 -- optimal, objective: 7.585718423559126
    155 -- optimal, objective: 3.395738532382068
    156 -- optimal, objective: 4.1496477010708315
    157 -- optimal, objective: 1.0001442053929652
    158 -- optimal, objective: 3.064493879763607
    159 -- optimal, objective: 5.014035878816186
    160 -- optimal, objective: 3.8397987755889864
    161 -- optimal, objective: 1.6576931969836117
    162 -- optimal, objective: 0.41176286053094346
    163 -- optimal, objective: 2.040676052347126
    164 -- optimal, objective: 2.0029956449691255
    165 -- optimal, objective: 2.511516365286103
    166 -- optimal, objective: 0.4825712086516878
    167 -- optimal, objective: 3.8889108963086514
    168 -- optimal, objective: 1.0769836582040213
    169 -- optimal, objective: 2.4991945390852033
    170 -- optimal, objective: 1.845216182624698
    171 -- optimal, objective: 4.516293133031205
    172 -- optimal, objective: 3.7260015810685214
    173 -- optimal, objective: 1.92057615962535
    174 -- optimal, objective: 1.604041225414677
    175 -- optimal, objective: 0.32970532780477385
    176 -- optimal, objective: 3.1773422885566145
    177 -- optimal, objective: 4.892213973195774
    178 -- optimal, objective: 1.734410725642894
    179 -- optimal, objective: 2.092997658635978
    180 -- optimal, objective: 1.98220182602681
    181 -- optimal, objective: 3.0950888485049233
    182 -- optimal, objective: 2.5625036101026635
    183 -- optimal, objective: 6.469916654594004
    184 -- optimal, objective: 2.067453311742285
    185 -- optimal, objective: 2.3845301568015937
    186 -- optimal, objective: 1.5120049498654058
    187 -- optimal, objective: 3.625438657158783
    188 -- optimal, objective: 0.9836691585295542
    189 -- optimal, objective: 1.9174264005471469
    190 -- optimal, objective: 1.0199757612466052
    191 -- optimal, objective: 1.811121385488405
    192 -- optimal, objective: 10.407088543311495
    193 -- optimal, objective: 5.725259035853387
    194 -- optimal, objective: 6.585221622378013
    195 -- optimal, objective: 1.1404147804459193
    196 -- optimal, objective: 4.636480679503004
    197 -- optimal, objective: 3.9218197675245206
    198 -- optimal, objective: 1.0045560725783425
    199 -- optimal, objective: 2.41818480451699
    200 -- optimal, objective: 2.9243929060257203
    201 -- optimal, objective: 2.9690050917379365
    202 -- optimal, objective: 2.615291414013093
    203 -- optimal, objective: 2.491422663946302
    204 -- optimal, objective: 1.7943475807253635
    205 -- optimal, objective: 5.708343478588523
    206 -- optimal, objective: 2.40560702096897
    207 -- optimal, objective: 0.9383083089043909
    208 -- optimal, objective: 4.796697378270656
    209 -- optimal, objective: 0.5067761258605022
    210 -- optimal, objective: 2.189061857465936
    211 -- optimal, objective: 3.216269088639679
    212 -- optimal, objective: 0.07970527067973973
    213 -- optimal, objective: 0.3907213231728183
    214 -- optimal, objective: 4.023957133776022
    215 -- optimal, objective: 3.5942319390497603
    216 -- optimal, objective: 1.6777705156089076
    217 -- optimal, objective: 4.848036844041154
    218 -- optimal, objective: 0.48855224752472187
    219 -- optimal, objective: 12.374512277226167
    220 -- optimal, objective: 1.4283806999186262
    221 -- optimal, objective: 1.8180497328202398
    222 -- optimal, objective: 0.4850228697953872
    223 -- optimal, objective: 2.506763240151563
    224 -- optimal, objective: 1.3976840129134251
    225 -- optimal, objective: 0.9031881755467174
    226 -- optimal, objective: 0.7285671677646417
    227 -- optimal, objective: 2.4704351482313247
    228 -- optimal, objective: 2.675081338577018
    229 -- optimal, objective: 3.3257208414746455
    230 -- optimal, objective: 2.5990602609202846
    231 -- optimal, objective: 4.837625773306227
    232 -- optimal, objective: 1.132944263759566
    233 -- optimal, objective: 1.6398759114014065
    234 -- optimal, objective: 3.0089349683658075
    235 -- optimal, objective: 1.4124067533104077
    236 -- optimal, objective: 5.77194919596976
    237 -- optimal, objective: 0.14937838316529164
    238 -- optimal, objective: 1.2057382957613954
    239 -- optimal, objective: 1.7168431018294332
    240 -- optimal, objective: 4.602199487444718
    241 -- optimal, objective: 2.1236394532093654
    242 -- optimal, objective: 2.5316250867772108
    243 -- optimal, objective: 1.7031702437787404
    244 -- optimal, objective: 2.2177868984914078
    245 -- optimal, objective: 0.6465620718111913
    246 -- optimal, objective: 1.291638547305451
    247 -- optimal, objective: 7.7898427618955655
    248 -- optimal, objective: 1.0605811788976358
    249 -- optimal, objective: 1.1514590587868343


.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function. Plot terminated.


