Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.core.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

====== ========= ========= ========== =
\      tag1      tag2      tag3       …
====== ========= ========= ========== =
index1 data(1,1) data(1,2) data(1, 3) …
index2 data(2,1) data(2,2) data(2, 3) …
…      …         …         …          …
====== ========= ========= ========== =

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

|       \| \| \| \| \|

\|——-|— —————|—————|——————-|—————————————————–\| \| tag1 \| model
reference 1 \| description 1 \| unit of measure 1 \| Additional
comments, additional columns are ignored \| \| tag2 \| model reference 2
\| description 2 \| unit of measure 2 \| … \| \| tag3 \| model reference
3 \| description 3 \| unit of measure 3 \| … \| \| … \| … \| … \| … \| …
\|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
“data_plot_book.pdf.”

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.models_extra.power_generation.properties.flue_gas_ideal import FlueGasParameterBlock
    from idaes.models.properties import iapws95
    from idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        HeatExchangerFlowPattern
    )
    import pyomo.environ as pyo

.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(dynamic=False)
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(
        cold_side={"property_package": m.fs.prop_water,
                   "has_pressure_change": True},
        hot_side={"property_package": m.fs.prop_fluegas,
                  "has_pressure_change": True},
        has_holdup=False,
        flow_pattern=HeatExchangerFlowPattern.countercurrent,
        tube_arrangement=TubeArrangement.inLine,
        cold_side_water_phase="Liq",
        has_radiation=False
    )

.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = pyo.value(iapws95.htpx(563.706*pyo.units.K, 2.5449e7*pyo.units.Pa))
    
    m.fs.econ.cold_side_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.cold_side_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.cold_side_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.hot_side.properties_in[0].flow_mol_comp[c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.hot_side_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.hot_side_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.cold_side_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.cold_side_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.cold_side_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "H2O"].value,
                "CO2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "CO2"].value,
                "N2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "N2"].value,
                "O2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "O2"].value,
                "NO": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "NO"].value,
                "SO2": m.fs.econ.hot_side_inlet.flow_mol_comp[0, "SO2"].value,
            },
            "temperature": m.fs.econ.hot_side_inlet.temperature[0].value,
            "pressure": m.fs.econ.hot_side_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ.cold_side: Initialization Complete
    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ.hot_side.properties_in: Initialisation Complete, optimal - Optimal Solution Found.
    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ.hot_side.properties_out: Initialisation Complete, optimal - Optimal Solution Found.
    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ.hot_side.properties_out: fs.econ.hot_side.properties_out State Released.
    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ.hot_side: Initialization Complete
    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ: fs.econ Initialisation Step 1 Complete.
    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ.hot_side.properties_in: fs.econ.hot_side.properties_in State Released.
    2023-03-04 00:37:03 [INFO] idaes.init.fs.econ: fs.econ Initialisation Complete.


3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.cold_side.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.cold_side.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.cold_side.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.cold_side.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.cold_side.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.cold_side.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.hot_side.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.hot_side.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.hot_side.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.hot_side.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.hot_side.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.hot_side.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.
    import idaes.core.util.tables as ta
    from idaes.core.util.tags import ModelTagGroup
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # this is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.cold_side_inlet,
            "ECON_OUT": m.fs.econ.cold_side_outlet,
            "FG_2_ECON": m.fs.econ.hot_side_inlet,
            "FG_2_AIRPH": m.fs.econ.hot_side_outlet,
        },
        sort=True,
    )
    
    # The next function converts the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ModelTagGroup()
    
    prop_dict = {
        "flow_mass": "_Fm",
        "flow_mol": "_F",
        "enth_mol": "_h",
        "temperature": "_T",
        "pressure": "_P",
    }
    comp_list = ["O2", "NO", "N2", "SO2", "CO2", "H2O"]
    
    for state, block in state_dict.items():
        for prop, suffix in prop_dict.items():
            comp = getattr(block, prop)
            recon_tags.add(expr=comp, name=state+suffix, format_string="{:.3f}")
        # Add tags for molar flow rates of each component
        for j in comp_list:
            # Not all components appear in all streams
            try:
                comp = block.flow_mol_comp[j]
                recon_tags.add(expr=comp, name=f"{state}_F[{j}]", format_string="{:.3f}")
            except KeyError:
                pass
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags.add(expr=m.fs.econ.heat_duty[0], name="ECON_Q", format_string="{:.3f}")

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.tags import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tag_group=recon_tags, outfile="econ_init.svg")

.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.hot_side.properties_in[0].flow_mol_comp[c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.cold_side_inlet.unfix()
    m.fs.econ.hot_side_inlet.unfix()
    m.fs.econ.cold_side_outlet.unfix()
    m.fs.econ.hot_side_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t].expression)
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.162233189049513
    1 -- optimal, objective: 0.8197864499890377
    2 -- optimal, objective: 1.4705020498256935
    3 -- optimal, objective: 1.189857907704723
    4 -- optimal, objective: 6.266862831653163
    5 -- optimal, objective: 2.353837799416417
    6 -- optimal, objective: 0.5232270065114349
    7 -- optimal, objective: 1.0234628569514197
    8 -- optimal, objective: 1.6923977208521481
    9 -- optimal, objective: 5.2001927458524815
    10 -- optimal, objective: 2.025697843022584
    11 -- optimal, objective: 1.3755022829200758
    12 -- optimal, objective: 1.8040084546445299
    13 -- optimal, objective: 1.0820697968576691
    14 -- optimal, objective: 2.872565777305536
    15 -- optimal, objective: 4.67937799614322
    16 -- optimal, objective: 2.528568205492066
    17 -- optimal, objective: 3.4191056355909857
    18 -- optimal, objective: 0.6733502043658735
    19 -- optimal, objective: 1.319145335199618
    20 -- optimal, objective: 2.5910789518941266
    21 -- optimal, objective: 0.7284892511624393
    22 -- optimal, objective: 3.0961354376478463
    23 -- optimal, objective: 8.046924273772275
    24 -- optimal, objective: 9.43448209882699
    25 -- optimal, objective: 2.908715618274521
    26 -- optimal, objective: 5.764858402612387
    27 -- optimal, objective: 1.5869947333050256
    28 -- optimal, objective: 0.984985846755098
    29 -- optimal, objective: 5.420724866466555
    30 -- optimal, objective: 0.15987314723602103
    31 -- optimal, objective: 1.9662745455935513
    32 -- optimal, objective: 4.631981600955086
    33 -- optimal, objective: 0.7898383615771254
    34 -- optimal, objective: 4.935318030659014
    35 -- optimal, objective: 2.782272921404931
    36 -- optimal, objective: 3.793536123463037
    37 -- optimal, objective: 7.399744163756616
    38 -- optimal, objective: 1.8234832495958113
    39 -- optimal, objective: 8.123197755316546
    40 -- optimal, objective: 2.466967374172636
    41 -- optimal, objective: 2.0589956697314933
    42 -- optimal, objective: 4.8248457733291366
    43 -- optimal, objective: 2.905354510994928
    44 -- optimal, objective: 1.2573498031485666
    45 -- optimal, objective: 2.762659514639471
    46 -- optimal, objective: 3.9105414166264967
    47 -- optimal, objective: 0.36385392135319716
    48 -- optimal, objective: 6.482045124670574
    49 -- optimal, objective: 0.8862853314576088
    50 -- optimal, objective: 0.3533301795603448
    51 -- optimal, objective: 0.6741716772663059
    52 -- optimal, objective: 1.4465656566076146
    53 -- optimal, objective: 2.3657224484004127
    54 -- optimal, objective: 1.4293144956084094
    55 -- optimal, objective: 11.608899577383612
    56 -- optimal, objective: 2.58455851471634
    57 -- optimal, objective: 2.2280418960622477
    58 -- optimal, objective: 2.4953667573534535
    59 -- optimal, objective: 1.6473143733650213
    60 -- optimal, objective: 8.024762155447483
    61 -- optimal, objective: 5.943580608761261
    62 -- optimal, objective: 2.3358112651340748
    63 -- optimal, objective: 4.385134901100451
    64 -- optimal, objective: 0.560799175854562
    65 -- optimal, objective: 2.1768860904785403
    66 -- optimal, objective: 2.823330562518629
    67 -- optimal, objective: 4.396916342718742
    68 -- optimal, objective: 3.391821500174393
    69 -- optimal, objective: 0.6148617687092183
    70 -- optimal, objective: 0.37082950310594304
    71 -- optimal, objective: 0.8762410268085017
    72 -- optimal, objective: 3.0086193562317574
    73 -- optimal, objective: 6.178310252873819
    74 -- optimal, objective: 2.451573865746723
    75 -- optimal, objective: 8.974808392536525
    76 -- optimal, objective: 1.7707013213288947
    77 -- optimal, objective: 3.126550408628944
    78 -- optimal, objective: 5.203564818159619
    79 -- optimal, objective: 4.769633196274132
    80 -- optimal, objective: 4.816640912308071
    81 -- optimal, objective: 0.6532705965568438
    82 -- optimal, objective: 2.496533905602491
    83 -- optimal, objective: 0.8032403793218194
    84 -- optimal, objective: 0.3628436163257618
    85 -- optimal, objective: 1.5238517213117821
    86 -- optimal, objective: 3.8657489171903254
    87 -- optimal, objective: 1.7222638616761776
    88 -- optimal, objective: 3.9538701224262356
    89 -- optimal, objective: 1.652363315868652
    90 -- optimal, objective: 3.351117802161984
    91 -- optimal, objective: 1.2094064053344051
    92 -- optimal, objective: 1.578703926570241
    93 -- optimal, objective: 3.4104161322802966
    94 -- optimal, objective: 1.2638744445652246
    95 -- optimal, objective: 3.2950269700523185
    96 -- optimal, objective: 1.5307297912772309
    97 -- optimal, objective: 2.05761954608524
    98 -- optimal, objective: 1.7332019198698796
    99 -- optimal, objective: 4.5882940070371845
    100 -- optimal, objective: 0.9292950798611611
    101 -- optimal, objective: 1.1035420871622976
    102 -- optimal, objective: 0.005403430398348473
    103 -- optimal, objective: 4.030379683993389
    104 -- optimal, objective: 2.597795304066636
    105 -- optimal, objective: 3.7186279044765995
    106 -- optimal, objective: 2.2200116456105965
    107 -- optimal, objective: 1.7361501009357467
    108 -- optimal, objective: 1.7827888202877085
    109 -- optimal, objective: 0.8012255957979243
    110 -- optimal, objective: 0.4890883099159503
    111 -- optimal, objective: 4.625468290420762
    112 -- optimal, objective: 4.073067561398375
    113 -- optimal, objective: 4.984142249931066
    114 -- optimal, objective: 4.500896627466503
    115 -- optimal, objective: 0.8012366493659611
    116 -- optimal, objective: 2.6875597539254534
    117 -- optimal, objective: 6.864914207638013
    118 -- optimal, objective: 3.0375383483446323
    119 -- optimal, objective: 2.4940926825731284
    120 -- optimal, objective: 0.4608312841131901
    121 -- optimal, objective: 0.044472703115556685
    122 -- optimal, objective: 1.9092249228765488
    123 -- optimal, objective: 4.153943649844283
    124 -- optimal, objective: 5.635795985484612
    125 -- optimal, objective: 4.722375449558998
    126 -- optimal, objective: 4.837800008333485
    127 -- optimal, objective: 2.8954190363540637
    128 -- optimal, objective: 0.1700741811184782
    129 -- optimal, objective: 0.9837965852425055
    130 -- optimal, objective: 8.052261850607373
    131 -- optimal, objective: 6.260300019995838
    132 -- optimal, objective: 2.5725785456389096
    133 -- optimal, objective: 3.7331869855923228
    134 -- optimal, objective: 0.3400612362222515
    135 -- optimal, objective: 3.603334225872026
    136 -- optimal, objective: 2.5015732182201598
    137 -- optimal, objective: 0.39639975764994373
    138 -- optimal, objective: 0.14140324820958775
    139 -- optimal, objective: 8.317346638086871
    140 -- optimal, objective: 5.424422727514921
    141 -- optimal, objective: 2.835727880542202
    142 -- optimal, objective: 1.5376133193670736
    143 -- optimal, objective: 3.62420847455183
    144 -- optimal, objective: 4.95468987699004
    145 -- optimal, objective: 0.5851604096299906
    146 -- optimal, objective: 4.899590933174665
    147 -- optimal, objective: 3.6822700946645632
    148 -- optimal, objective: 2.1210809671681665
    149 -- optimal, objective: 1.7199975728800592
    150 -- optimal, objective: 3.3189081004097685
    151 -- optimal, objective: 0.36850247207845116
    152 -- optimal, objective: 1.9488439097577848
    153 -- optimal, objective: 2.6747587962821764
    154 -- optimal, objective: 7.585718423558681
    155 -- optimal, objective: 3.3957385323820666
    156 -- optimal, objective: 4.149647701071187
    157 -- optimal, objective: 1.00014420539314
    158 -- optimal, objective: 3.0644938797638197
    159 -- optimal, objective: 5.01403587881666
    160 -- optimal, objective: 3.839798775588395
    161 -- optimal, objective: 1.657693196983643
    162 -- optimal, objective: 0.4117628605309538
    163 -- optimal, objective: 2.040676052347117
    164 -- optimal, objective: 2.0029956449691237
    165 -- optimal, objective: 2.5115163652861745
    166 -- optimal, objective: 0.4825712086516862
    167 -- optimal, objective: 3.8889108963087597
    168 -- optimal, objective: 1.0769836582038064
    169 -- optimal, objective: 2.4991945390852
    170 -- optimal, objective: 1.8452161826248141
    171 -- optimal, objective: 4.516293133031545
    172 -- optimal, objective: 3.726001581068362
    173 -- optimal, objective: 1.9205761596254864
    174 -- optimal, objective: 1.6040412254146332
    175 -- optimal, objective: 0.32970532780477046
    176 -- optimal, objective: 3.177342288556746
    177 -- optimal, objective: 4.89221397319579
    178 -- optimal, objective: 1.7344107256429597
    179 -- optimal, objective: 2.0929976586359733
    180 -- optimal, objective: 1.982201826026694
    181 -- optimal, objective: 3.095088848504217
    182 -- optimal, objective: 2.562503610102643
    183 -- optimal, objective: 6.469916654594585
    184 -- optimal, objective: 2.0674533117423524
    185 -- optimal, objective: 2.384530156801701
    186 -- optimal, objective: 1.5120049498649166
    187 -- optimal, objective: 3.625438657158712
    188 -- optimal, objective: 0.9836691585294396
    189 -- optimal, objective: 1.917426400547082
    190 -- optimal, objective: 1.0199757612466174
    191 -- optimal, objective: 1.8111213854884678
    192 -- optimal, objective: 10.407088543311442
    193 -- optimal, objective: 5.725259035853156
    194 -- optimal, objective: 6.585221622378477
    195 -- optimal, objective: 1.140414780445884
    196 -- optimal, objective: 4.636480679503039
    197 -- optimal, objective: 3.9218197675245263
    198 -- optimal, objective: 1.0045560725784672
    199 -- optimal, objective: 2.4181848045169296
    200 -- optimal, objective: 2.9243929060257288
    201 -- optimal, objective: 2.9690050917378223
    202 -- optimal, objective: 2.615291414013144
    203 -- optimal, objective: 2.4914226639464037
    204 -- optimal, objective: 1.7943475807253635
    205 -- optimal, objective: 5.708343478588303
    206 -- optimal, objective: 2.4056070209689553
    207 -- optimal, objective: 0.9383083089043902
    208 -- optimal, objective: 4.796697378270855
    209 -- optimal, objective: 0.5067761258604929
    210 -- optimal, objective: 2.1890618574660134
    211 -- optimal, objective: 3.2162690886397387
    212 -- optimal, objective: 0.07970527067973067
    213 -- optimal, objective: 0.39072132317282576
    214 -- optimal, objective: 4.023957133776316
    215 -- optimal, objective: 3.594231939050225
    216 -- optimal, objective: 1.6777705156088851
    217 -- optimal, objective: 4.8480368440411645
    218 -- optimal, objective: 0.48855224752477033
    219 -- optimal, objective: 12.374512277226524
    220 -- optimal, objective: 1.4283806999184692
    221 -- optimal, objective: 1.8180497328202565
    222 -- optimal, objective: 0.4850228697954438
    223 -- optimal, objective: 2.5067632401516753
    224 -- optimal, objective: 1.3976840129134207
    225 -- optimal, objective: 0.903188175546587
    226 -- optimal, objective: 0.7285671677649479
    227 -- optimal, objective: 2.4704351482314926
    228 -- optimal, objective: 2.675081338577224
    229 -- optimal, objective: 3.3257208414744817
    230 -- optimal, objective: 2.5990602609204148
    231 -- optimal, objective: 4.837625773306359
    232 -- optimal, objective: 1.1329442637595102
    233 -- optimal, objective: 1.6398759114014736
    234 -- optimal, objective: 3.008934968366082
    235 -- optimal, objective: 1.4124067533104032
    236 -- optimal, objective: 5.771949195968895
    237 -- optimal, objective: 0.1493783831652379
    238 -- optimal, objective: 1.205738295761327
    239 -- optimal, objective: 1.7168431018295884
    240 -- optimal, objective: 4.602199487444568
    241 -- optimal, objective: 2.1236394532092833
    242 -- optimal, objective: 2.5316250867770487
    243 -- optimal, objective: 1.7031702437789242
    244 -- optimal, objective: 2.2177868984914086
    245 -- optimal, objective: 0.646562071811192
    246 -- optimal, objective: 1.2916385473054528
    247 -- optimal, objective: 7.789842761895642
    248 -- optimal, objective: 1.0605811788975847
    249 -- optimal, objective: 1.1514590587866702


.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function. Plot terminated.


