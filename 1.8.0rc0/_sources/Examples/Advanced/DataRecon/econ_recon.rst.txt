Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

+--------+-----------+-----------+------------+---+
|        | tag1      | tag2      | tag3       | … |
+========+===========+===========+============+===+
| index1 | data(1,1) | data(1,2) | data(1, 3) | … |
+--------+-----------+-----------+------------+---+
| index2 | data(2,1) | data(2,2) | data(2, 3) | … |
+--------+-----------+-----------+------------+---+
| …      | …         | …         | …          | … |
+--------+-----------+-----------+------------+---+

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

|       \| \| \| \| \|

\|——-|— —————|—————|——————-|—————————————————–\| \| tag1 \| model
reference 1 \| description 1 \| unit of measure 1 \| Additional
comments, additional columns are ignored \| \| tag2 \| model reference 2
\| description 2 \| unit of measure 2 \| … \| \| tag3 \| model reference
3 \| description 3 \| unit of measure 3 \| … \| \| … \| … \| … \| … \| …
\|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
“data_plot_book.pdf.”

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.power_generation.properties.flue_gas_ideal import FlueGasParameterBlock
    from idaes.generic_models.properties import iapws95
    from idaes.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        DeltaTMethod
    )
    import pyomo.environ as pyo

.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(default={"dynamic": False})
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(default={
            "side_1_property_package": m.fs.prop_water,
            "side_2_property_package": m.fs.prop_fluegas,
            "has_pressure_change": True,
            "has_holdup": False,
            "delta_T_method": DeltaTMethod.counterCurrent,
            "tube_arrangement": TubeArrangement.inLine,
            "side_1_water_phase": "Liq",
            "has_radiation": False
        }
    )

.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = pyo.value(iapws95.htpx(563.706*pyo.units.K, 2.5449e7*pyo.units.Pa))
    
    m.fs.econ.side_1_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.side_1_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.side_1_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.side_2.properties_in[0].flow_mol_comp[c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.side_2_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.side_2_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.side_1_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.side_1_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.side_1_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.side_2_inlet.flow_mol_comp[0, "H2O"].value,
                "CO2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "CO2"].value,
                "N2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "N2"].value,
                "O2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "O2"].value,
                "NO": m.fs.econ.side_2_inlet.flow_mol_comp[0, "NO"].value,
                "SO2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "SO2"].value,
            },
            "temperature": m.fs.econ.side_2_inlet.temperature[0].value,
            "pressure": m.fs.econ.side_2_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ.side_1: Initialization Complete
    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ.side_2.properties_in: Initialisation Complete, optimal - Optimal Solution Found.
    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ.side_2.properties_out: Initialisation Complete, optimal - Optimal Solution Found.
    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ.side_2.properties_out: fs.econ.side_2.properties_out State Released.
    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ.side_2: Initialization Complete
    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ: fs.econ Initialisation Step 1 Complete.
    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ.side_2.properties_in: fs.econ.side_2.properties_in State Released.
    2020-12-23 15:19:58 [INFO] idaes.init.fs.econ: fs.econ Initialisation Complete.


3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()
    m.fs.econ.LMTD.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.  
    import idaes.core.util.tables as ta
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # this is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.side_1_inlet,
            "ECON_OUT": m.fs.econ.side_1_outlet,
            "FG_2_ECON": m.fs.econ.side_2_inlet,
            "FG_2_AIRPH": m.fs.econ.side_2_outlet,
        },
        sort=True,
    )
    
    # The next function converts the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ta.tag_state_quantities(
        blocks=state_dict, 
        attributes=(
            "flow_mass", 
            "flow_mol", 
            "enth_mol", 
            "temperature", 
            "pressure", 
            ("flow_mol_comp", "O2"),
            ("flow_mol_comp", "NO"),
            ("flow_mol_comp", "N2"),
            ("flow_mol_comp", "SO2"),
            ("flow_mol_comp", "CO2"),
            ("flow_mol_comp", "H2O"),
        ), 
        labels=("_Fm", "_F", "_h", "_T", "_P", "_F[O2]", "_F[NO]", "_F[N2]", "_F[SO2]", "_F[CO2]", "_F[H2O]"),
    )
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags["ECON_Q"] = m.fs.econ.heat_duty[0]

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.misc import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tags={"subtitle":"Initialized Model"})
        s = svg_tag(svg=s, tags=recon_tags, outfile="econ_init.svg")

.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.side_2.properties_in[0].flow_mol_comp[c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.side_1_inlet.unfix()
    m.fs.econ.side_2_inlet.unfix()
    m.fs.econ.side_1_outlet.unfix()
    m.fs.econ.side_2_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t])
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.162201360626731
    1 -- optimal, objective: 0.8197916348655697
    2 -- optimal, objective: 1.4704841795757553
    3 -- optimal, objective: 1.189890367808889
    4 -- optimal, objective: 6.266902064585287
    5 -- optimal, objective: 2.3537989757334357
    6 -- optimal, objective: 0.5232362409291107
    7 -- optimal, objective: 1.0234347889957127
    8 -- optimal, objective: 1.6923646000432893
    9 -- optimal, objective: 5.200181621761052
    10 -- optimal, objective: 2.0256788832442947
    11 -- optimal, objective: 1.3755282573107253
    12 -- optimal, objective: 1.8040411950226256
    13 -- optimal, objective: 1.0820452721992098
    14 -- optimal, objective: 2.8725508346784947
    15 -- optimal, objective: 4.679431401768796
    16 -- optimal, objective: 2.5285462489990134
    17 -- optimal, objective: 3.4190566068991637
    18 -- optimal, objective: 0.6733248046042095
    19 -- optimal, objective: 1.319117422958569
    20 -- optimal, objective: 2.591126369762744
    21 -- optimal, objective: 0.7284969800023037
    22 -- optimal, objective: 3.0960880080284956
    23 -- optimal, objective: 8.046882712386559
    24 -- optimal, objective: 9.434438819029033
    25 -- optimal, objective: 2.908666060552317
    26 -- optimal, objective: 5.764854776323206
    27 -- optimal, objective: 1.5869850001197585
    28 -- optimal, objective: 0.9849706870359749
    29 -- optimal, objective: 5.420696622705167
    30 -- optimal, objective: 0.16066578746341725
    31 -- optimal, objective: 1.966263322754751
    32 -- optimal, objective: 4.631928468438954
    33 -- optimal, objective: 0.7898326457669559
    34 -- optimal, objective: 4.935316816207466
    35 -- optimal, objective: 2.782217553674161
    36 -- optimal, objective: 3.793604211883175
    37 -- optimal, objective: 7.399694410586127
    38 -- optimal, objective: 1.8234931889047832
    39 -- optimal, objective: 8.123278203552523
    40 -- optimal, objective: 2.4669893302567174
    41 -- optimal, objective: 2.0590537122732395
    42 -- optimal, objective: 4.82489004591239
    43 -- optimal, objective: 2.9053626799280714
    44 -- optimal, objective: 1.2572997144472362
    45 -- optimal, objective: 2.762645380939181
    46 -- optimal, objective: 3.910604606244248
    47 -- optimal, objective: 0.363845471889447
    48 -- optimal, objective: 6.4821230867246245
    49 -- optimal, objective: 0.8862884524239288
    50 -- optimal, objective: 0.3533378896239374
    51 -- optimal, objective: 0.6741934666897618
    52 -- optimal, objective: 1.446566598089191
    53 -- optimal, objective: 2.365692115533428
    54 -- optimal, objective: 1.4292836233967607
    55 -- optimal, objective: 11.608835808833684
    56 -- optimal, objective: 2.5845585364935517
    57 -- optimal, objective: 2.2280318353692845
    58 -- optimal, objective: 2.495393965552178
    59 -- optimal, objective: 1.647288759007145
    60 -- optimal, objective: 8.024825566331165
    61 -- optimal, objective: 5.943553444690273
    62 -- optimal, objective: 2.3357860625597966
    63 -- optimal, objective: 4.385139025177349
    64 -- optimal, objective: 0.5607805981598368
    65 -- optimal, objective: 2.17684713563519
    66 -- optimal, objective: 2.8232836736978957
    67 -- optimal, objective: 4.396906443658432
    68 -- optimal, objective: 3.391855930037592
    69 -- optimal, objective: 0.6148795243220353
    70 -- optimal, objective: 0.3708280914478981
    71 -- optimal, objective: 0.8762641865696765
    72 -- optimal, objective: 3.0086342942362605
    73 -- optimal, objective: 6.178275683704521
    74 -- optimal, objective: 2.451595715490864
    75 -- optimal, objective: 8.974736425700616
    76 -- optimal, objective: 1.770665588225571
    77 -- optimal, objective: 3.126518971476488
    78 -- optimal, objective: 5.205301238989052
    79 -- optimal, objective: 4.769597864830071
    80 -- optimal, objective: 4.81664474643678
    81 -- optimal, objective: 0.6532812835414418
    82 -- optimal, objective: 2.4965181358360184
    83 -- optimal, objective: 0.8032343482261965
    84 -- optimal, objective: 0.36282493375244135
    85 -- optimal, objective: 1.5238238194806921
    86 -- optimal, objective: 3.865787830956084
    87 -- optimal, objective: 1.72227496687158
    88 -- optimal, objective: 3.953876969181429
    89 -- optimal, objective: 1.6523612426748613
    90 -- optimal, objective: 3.351063841683936
    91 -- optimal, objective: 1.2093955196393513
    92 -- optimal, objective: 1.5787045321363251
    93 -- optimal, objective: 3.4104193014724715
    94 -- optimal, objective: 1.2638978913500514
    95 -- optimal, objective: 3.295009386413302
    96 -- optimal, objective: 1.5306978267036129
    97 -- optimal, objective: 2.0576162766855535
    98 -- optimal, objective: 1.7332102521609307
    99 -- optimal, objective: 4.588249738738
    100 -- optimal, objective: 0.9295175448471328
    101 -- optimal, objective: 1.1035561284196085
    102 -- optimal, objective: 0.005402403281198675
    103 -- optimal, objective: 4.030350825818051
    104 -- optimal, objective: 2.5977688471874356
    105 -- optimal, objective: 3.7186572151823363
    106 -- optimal, objective: 2.2200012303835615
    107 -- optimal, objective: 1.7361821672876043
    108 -- optimal, objective: 1.7827948173523849
    109 -- optimal, objective: 0.8012022277038493
    110 -- optimal, objective: 0.48906972652974
    111 -- optimal, objective: 4.625396349830877
    112 -- optimal, objective: 4.073050044233066
    113 -- optimal, objective: 4.984164789951558
    114 -- optimal, objective: 4.500918344081738
    115 -- optimal, objective: 0.8012413198265821
    116 -- optimal, objective: 2.687543401764745
    117 -- optimal, objective: 6.864934379080642
    118 -- optimal, objective: 3.0375805861816834
    119 -- optimal, objective: 2.49410888902467
    120 -- optimal, objective: 0.46083351785483184
    121 -- optimal, objective: 0.0444713315916452
    122 -- optimal, objective: 1.9091826645137482
    123 -- optimal, objective: 4.153927862805069
    124 -- optimal, objective: 5.635821162573148
    125 -- optimal, objective: 4.722448584729619
    126 -- optimal, objective: 4.838421311326484
    127 -- optimal, objective: 2.895359847029965
    128 -- optimal, objective: 0.1700702801133677
    129 -- optimal, objective: 0.9837813189593976
    130 -- optimal, objective: 8.052242413116716
    131 -- optimal, objective: 6.260349530098688
    132 -- optimal, objective: 2.5726387350162323
    133 -- optimal, objective: 3.733230649108102
    134 -- optimal, objective: 0.3400649625011765
    135 -- optimal, objective: 3.603279268819368
    136 -- optimal, objective: 2.501572849060056
    137 -- optimal, objective: 0.396413395001413
    138 -- optimal, objective: 0.1414040424714755
    139 -- optimal, objective: 8.31724058642851
    140 -- optimal, objective: 5.424448709520692
    141 -- optimal, objective: 2.8357713483634304
    142 -- optimal, objective: 1.5375770466936693
    143 -- optimal, objective: 3.62417161274437
    144 -- optimal, objective: 4.95473170544504
    145 -- optimal, objective: 0.5851578341559385
    146 -- optimal, objective: 4.899534932815463
    147 -- optimal, objective: 3.68226617363569
    148 -- optimal, objective: 2.12110796996283
    149 -- optimal, objective: 1.719942839659492
    150 -- optimal, objective: 3.3189214980332946
    151 -- optimal, objective: 0.36851885526624245
    152 -- optimal, objective: 1.9488105776159992
    153 -- optimal, objective: 2.674787042416221
    154 -- optimal, objective: 7.585656605848277
    155 -- optimal, objective: 3.3957387225186704
    156 -- optimal, objective: 4.149600126698102
    157 -- optimal, objective: 1.0001276150024154
    158 -- optimal, objective: 3.064461425586048
    159 -- optimal, objective: 5.013992307955744
    160 -- optimal, objective: 3.839860017220915
    161 -- optimal, objective: 1.6576814935989324
    162 -- optimal, objective: 0.41178378891995565
    163 -- optimal, objective: 2.040684602788004
    164 -- optimal, objective: 2.002997772812933
    165 -- optimal, objective: 2.5114799236150005
    166 -- optimal, objective: 0.48258914652155005
    167 -- optimal, objective: 3.88897665762616
    168 -- optimal, objective: 1.0769465308248678
    169 -- optimal, objective: 2.499193200876668
    170 -- optimal, objective: 1.8451901507025492
    171 -- optimal, objective: 4.516240233107762
    172 -- optimal, objective: 3.725949852223958
    173 -- optimal, objective: 1.9205975302203033
    174 -- optimal, objective: 1.604047683771162
    175 -- optimal, objective: 0.3297073490067171
    176 -- optimal, objective: 3.1773026407607725
    177 -- optimal, objective: 4.89221062867923
    178 -- optimal, objective: 1.7344424108100323
    179 -- optimal, objective: 2.0930393921889285
    180 -- optimal, objective: 1.9821792611906623
    181 -- optimal, objective: 3.09501308511659
    182 -- optimal, objective: 2.562542928308231
    183 -- optimal, objective: 6.4698400166612915
    184 -- optimal, objective: 2.0674756021956657
    185 -- optimal, objective: 2.384546297264492
    186 -- optimal, objective: 1.511966747607921
    187 -- optimal, objective: 3.625376290998284
    188 -- optimal, objective: 0.9836489663297723
    189 -- optimal, objective: 1.9174021295225292
    190 -- optimal, objective: 1.020004967852336
    191 -- optimal, objective: 1.8111147486376176
    192 -- optimal, objective: 10.407007486649107
    193 -- optimal, objective: 5.725212636472559
    194 -- optimal, objective: 6.58512102353377
    195 -- optimal, objective: 1.1403803946151294
    196 -- optimal, objective: 4.636496073472274
    197 -- optimal, objective: 3.921771186999416
    198 -- optimal, objective: 1.0045702656827604
    199 -- optimal, objective: 2.418215480546084
    200 -- optimal, objective: 2.9243580215266585
    201 -- optimal, objective: 2.9689758379686784
    202 -- optimal, objective: 2.615284972301529
    203 -- optimal, objective: 2.491409118030827
    204 -- optimal, objective: 1.7943475942577944
    205 -- optimal, objective: 5.708286126988958
    206 -- optimal, objective: 2.405602484543314
    207 -- optimal, objective: 0.9383323510763681
    208 -- optimal, objective: 4.79666299150672
    209 -- optimal, objective: 0.5067734258626428
    210 -- optimal, objective: 2.1890884578836025
    211 -- optimal, objective: 3.216278312969723
    212 -- optimal, objective: 0.07969866183076474
    213 -- optimal, objective: 0.390716698812657
    214 -- optimal, objective: 4.024001493294727
    215 -- optimal, objective: 3.594279949173608
    216 -- optimal, objective: 1.6777857029028451
    217 -- optimal, objective: 4.848031703923896
    218 -- optimal, objective: 0.48853441088524224
    219 -- optimal, objective: 12.374570705038003
    220 -- optimal, objective: 1.42841106049652
    221 -- optimal, objective: 1.818042749358935
    222 -- optimal, objective: 0.4850085026530109
    223 -- optimal, objective: 2.5067851806563883
    224 -- optimal, objective: 1.397681298415295
    225 -- optimal, objective: 0.9031717605984818
    226 -- optimal, objective: 0.7285447496524835
    227 -- optimal, objective: 2.4703912750521186
    228 -- optimal, objective: 2.6751347847077462
    229 -- optimal, objective: 3.325674612581574
    230 -- optimal, objective: 2.5990372980400065
    231 -- optimal, objective: 4.837605778149405
    232 -- optimal, objective: 1.1329234883415835
    233 -- optimal, objective: 1.6398399431285713
    234 -- optimal, objective: 3.00898335054957
    235 -- optimal, objective: 1.4124043086038285
    236 -- optimal, objective: 5.771998515376793
    237 -- optimal, objective: 0.1493890601568308
    238 -- optimal, objective: 1.205747487805767
    239 -- optimal, objective: 1.7168126471502356
    240 -- optimal, objective: 4.6022179127567195
    241 -- optimal, objective: 2.1236286863591114
    242 -- optimal, objective: 2.5315899941167843
    243 -- optimal, objective: 1.703140843013913
    244 -- optimal, objective: 2.2177940017210536
    245 -- optimal, objective: 0.6465659506433665
    246 -- optimal, objective: 1.2916365175647517
    247 -- optimal, objective: 7.790258421170838
    248 -- optimal, objective: 1.060558078675754
    249 -- optimal, objective: 1.1515044674819641


.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function. Plot terminated.


