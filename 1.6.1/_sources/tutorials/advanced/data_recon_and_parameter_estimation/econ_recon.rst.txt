Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

+--------+-----------+-----------+------------+---+
|        | tag1      | tag2      | tag3       | … |
+========+===========+===========+============+===+
| index1 | data(1,1) | data(1,2) | data(1, 3) | … |
+--------+-----------+-----------+------------+---+
| index2 | data(2,1) | data(2,2) | data(2, 3) | … |
+--------+-----------+-----------+------------+---+
| …      | …         | …         | …          | … |
+--------+-----------+-----------+------------+---+

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

|       \| \| \| \| \|

\|——-|— —————|—————|——————-|—————————————————–\| \| tag1 \| model
reference 1 \| description 1 \| unit of measure 1 \| Additional
comments, additional columns are ignored \| \| tag2 \| model reference 2
\| description 2 \| unit of measure 2 \| … \| \| tag3 \| model reference
3 \| description 3 \| unit of measure 3 \| … \| \| … \| … \| … \| … \| …
\|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
“data_plot_book.pdf.”

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.power_generation.properties.IdealProp_FlueGas import FlueGasParameterBlock
    from idaes.generic_models.properties import iapws95
    from idaes.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        DeltaTMethod
    )
    import pyomo.environ as pyo

.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(default={"dynamic": False})
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(default={
            "side_1_property_package": m.fs.prop_water,
            "side_2_property_package": m.fs.prop_fluegas,
            "has_pressure_change": True,
            "has_holdup": False,
            "delta_T_method": DeltaTMethod.counterCurrent,
            "tube_arrangement": TubeArrangement.inLine,
            "side_1_water_phase": "Liq",
            "has_radiation": False
        }
    )

.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = iapws95.htpx(563.706, 2.5449e7)
    
    m.fs.econ.side_1_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.side_1_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.side_1_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.side_2_inlet.flow_component[0, c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.side_2_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.side_2_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.side_1_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.side_1_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.side_1_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.side_2_inlet.flow_component[0, "H2O"].value,
                "CO2": m.fs.econ.side_2_inlet.flow_component[0, "CO2"].value,
                "N2": m.fs.econ.side_2_inlet.flow_component[0, "N2"].value,
                "O2": m.fs.econ.side_2_inlet.flow_component[0, "O2"].value,
                "NO": m.fs.econ.side_2_inlet.flow_component[0, "NO"].value,
                "SO2": m.fs.econ.side_2_inlet.flow_component[0, "SO2"].value,
            },
            "temperature": m.fs.econ.side_2_inlet.temperature[0].value,
            "pressure": m.fs.econ.side_2_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2020-08-07 15:18:20 [INFO] idaes.init.fs.econ.side_1: Initialization Complete
    2020-08-07 15:18:20 [INFO] idaes.init.fs.econ.side_2: Initialization Complete


3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()
    m.fs.econ.LMTD.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.  
    import idaes.core.util.tables as ta
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # there is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.side_1_inlet,
            "ECON_OUT": m.fs.econ.side_1_outlet,
            "FG_2_ECON": m.fs.econ.side_2_inlet,
            "FG_2_AIRPH": m.fs.econ.side_2_outlet,
        },
        sort=True,
    )
    
    # The next function convers the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ta.tag_state_quantities(
        blocks=state_dict, 
        attributes=(
            "flow_mass", 
            "flow_mol", 
            "enth_mol", 
            "temperature", 
            "pressure", 
            ("flow_component", "O2"),
            ("flow_component", "NO"),
            ("flow_component", "N2"),
            ("flow_component", "SO2"),
            ("flow_component", "CO2"),
            ("flow_component", "H2O"),
        ), 
        labels=("_Fm", "_F", "_h", "_T", "_P", "_F[O2]", "_F[NO]", "_F[N2]", "_F[SO2]", "_F[CO2]", "_F[H2O]"),
    )
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags["ECON_Q"] = m.fs.econ.heat_duty[0]

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.misc import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tags={"subtitle":"Initialized Model"})
        s = svg_tag(svg=s, tags=recon_tags, outfile="econ_init.svg")

.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.side_2_inlet.flow_component[0, c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.side_1_inlet.unfix()
    m.fs.econ.side_2_inlet.unfix()
    m.fs.econ.side_1_outlet.unfix()
    m.fs.econ.side_2_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t])
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.1622013606259403
    1 -- optimal, objective: 0.8197916348691106
    2 -- optimal, objective: 1.4704841795758476
    3 -- optimal, objective: 1.1898903619192618
    4 -- optimal, objective: 6.2669020645850475
    5 -- optimal, objective: 2.3537989757333984
    6 -- optimal, objective: 0.5232362334703197
    7 -- optimal, objective: 1.0234347889957929
    8 -- optimal, objective: 1.6923646000308887
    9 -- optimal, objective: 5.200181602792344
    10 -- optimal, objective: 2.0256788832442476
    11 -- optimal, objective: 1.3755282573108274
    12 -- optimal, objective: 1.8040411950227124
    13 -- optimal, objective: 1.0820452722033589
    14 -- optimal, objective: 2.872550834678532
    15 -- optimal, objective: 4.679431401771564
    16 -- optimal, objective: 2.5285462489989046
    17 -- optimal, objective: 3.4190566068988817
    18 -- optimal, objective: 0.673324804604065
    19 -- optimal, objective: 1.3191174229584879
    20 -- optimal, objective: 2.59112636976326
    21 -- optimal, objective: 0.7284969800022754
    22 -- optimal, objective: 3.0960880080304793
    23 -- optimal, objective: 8.046882712392671
    24 -- optimal, objective: 9.434438819029111
    25 -- optimal, objective: 2.9086660605554826
    26 -- optimal, objective: 5.7648547763232205
    27 -- optimal, objective: 1.586985000120259
    28 -- optimal, objective: 0.9849706870360163
    29 -- optimal, objective: 5.420696622705059
    30 -- optimal, objective: 0.16069807809738007
    31 -- optimal, objective: 1.9662633227541404
    32 -- optimal, objective: 4.631928468439229
    33 -- optimal, objective: 0.7898326457669502
    34 -- optimal, objective: 4.935316816207512
    35 -- optimal, objective: 2.782217553677175
    36 -- optimal, objective: 3.7936042118834172
    37 -- optimal, objective: 7.399694410587746
    38 -- optimal, objective: 1.823493188904721
    39 -- optimal, objective: 8.12327820355242
    40 -- optimal, objective: 2.4669893302638024
    41 -- optimal, objective: 2.059053759504696
    42 -- optimal, objective: 4.8248900459121264
    43 -- optimal, objective: 2.905362679931912
    44 -- optimal, objective: 1.2572997144473075
    45 -- optimal, objective: 2.7626453809391722
    46 -- optimal, objective: 3.910604606261468
    47 -- optimal, objective: 0.3638454718893506
    48 -- optimal, objective: 6.482123086792309
    49 -- optimal, objective: 0.8862884524239214
    50 -- optimal, objective: 0.35333788962389834
    51 -- optimal, objective: 0.6741934666897099
    52 -- optimal, objective: 1.4465665980891884
    53 -- optimal, objective: 2.3656921156999724
    54 -- optimal, objective: 1.4292836233968338
    55 -- optimal, objective: 11.60883580893586
    56 -- optimal, objective: 2.5845585364935517
    57 -- optimal, objective: 2.228031835877924
    58 -- optimal, objective: 2.4953939655523003
    59 -- optimal, objective: 1.6472887590075036
    60 -- optimal, objective: 8.02482556633122
    61 -- optimal, objective: 5.943553444690135
    62 -- optimal, objective: 2.3357860625599907
    63 -- optimal, objective: 4.38513902517734
    64 -- optimal, objective: 0.5607805981597314
    65 -- optimal, objective: 2.176847135635505
    66 -- optimal, objective: 2.823283673697595
    67 -- optimal, objective: 4.396906443658454
    68 -- optimal, objective: 3.391855930037684
    69 -- optimal, objective: 0.6148795243219459
    70 -- optimal, objective: 0.37082809144804085
    71 -- optimal, objective: 0.876264186856611
    72 -- optimal, objective: 3.0086342942205317
    73 -- optimal, objective: 6.17827568370467
    74 -- optimal, objective: 2.4515957167720552
    75 -- optimal, objective: 8.974736425709432
    76 -- optimal, objective: 1.7706655882253928
    77 -- optimal, objective: 3.1265189714766537
    78 -- optimal, objective: 5.205386216685979
    79 -- optimal, objective: 4.769597864830404
    80 -- optimal, objective: 4.816644746436785
    81 -- optimal, objective: 0.6532812835413844
    82 -- optimal, objective: 2.4965181358357427
    83 -- optimal, objective: 0.8032343482262069
    84 -- optimal, objective: 0.362824933753557
    85 -- optimal, objective: 1.5238238194806089
    86 -- optimal, objective: 3.8657878309489
    87 -- optimal, objective: 1.722274966870722
    88 -- optimal, objective: 3.953876969401788
    89 -- optimal, objective: 1.6523612442371725
    90 -- optimal, objective: 3.3510638416839695
    91 -- optimal, objective: 1.2093955196399642
    92 -- optimal, objective: 1.578704532136325
    93 -- optimal, objective: 3.4104193014724844
    94 -- optimal, objective: 1.2638978913502463
    95 -- optimal, objective: 3.2950093864133887
    96 -- optimal, objective: 1.5306978267035993
    97 -- optimal, objective: 2.0576162766855557
    98 -- optimal, objective: 1.7332102521609185
    99 -- optimal, objective: 4.588275042310542
    100 -- optimal, objective: 0.9295646078237197
    101 -- optimal, objective: 1.1035561284196103
    102 -- optimal, objective: 0.005402403281230255
    103 -- optimal, objective: 4.030350825818044
    104 -- optimal, objective: 2.5977688471873943
    105 -- optimal, objective: 3.7186572151966146
    106 -- optimal, objective: 2.2200012303853773
    107 -- optimal, objective: 1.7361821672875986
    108 -- optimal, objective: 1.7827948173524062
    109 -- optimal, objective: 0.8012022277038092
    110 -- optimal, objective: 0.489069726529739
    111 -- optimal, objective: 4.625396349830953
    112 -- optimal, objective: 4.073050044233075
    113 -- optimal, objective: 4.984164789951579
    114 -- optimal, objective: 4.500918344081859
    115 -- optimal, objective: 0.8012413198266072
    116 -- optimal, objective: 2.6875434017646866
    117 -- optimal, objective: 6.864934379080624
    118 -- optimal, objective: 3.037580586181703
    119 -- optimal, objective: 2.494108889024821
    120 -- optimal, objective: 0.4608335178548574
    121 -- optimal, objective: 0.04447133159167354
    122 -- optimal, objective: 1.9091826645260614
    123 -- optimal, objective: 4.15392786280511
    124 -- optimal, objective: 5.635821162569064
    125 -- optimal, objective: 4.722448584729763
    126 -- optimal, objective: 4.8384258645453695
    127 -- optimal, objective: 2.8953598470321897
    128 -- optimal, objective: 0.17007028011237482
    129 -- optimal, objective: 0.983781318959416
    130 -- optimal, objective: 8.052244544966099
    131 -- optimal, objective: 6.260349530091071
    132 -- optimal, objective: 2.5726387350164654
    133 -- optimal, objective: 3.7332306499363805
    134 -- optimal, objective: 0.3400649625009724
    135 -- optimal, objective: 3.6032792688379254
    136 -- optimal, objective: 2.5015728490600546
    137 -- optimal, objective: 0.3964133949983514
    138 -- optimal, objective: 0.14140404247121324
    139 -- optimal, objective: 8.317240586449977
    140 -- optimal, objective: 5.424448709519687
    141 -- optimal, objective: 2.835771348358169
    142 -- optimal, objective: 1.5375770466938208
    143 -- optimal, objective: 3.624171612808834
    144 -- optimal, objective: 4.954731705445279
    145 -- optimal, objective: 0.5851578341559879
    146 -- optimal, objective: 4.899534932885419
    147 -- optimal, objective: 3.6822661736354996
    148 -- optimal, objective: 2.1211079699625595
    149 -- optimal, objective: 1.719942839719281
    150 -- optimal, objective: 3.318921498033307
    151 -- optimal, objective: 0.3685188552662153
    152 -- optimal, objective: 1.9488105777326215
    153 -- optimal, objective: 2.6747870424160416
    154 -- optimal, objective: 7.585656605848192
    155 -- optimal, objective: 3.3957387225187117
    156 -- optimal, objective: 4.14960012696476
    157 -- optimal, objective: 1.0001276150027434
    158 -- optimal, objective: 3.0644614255859404
    159 -- optimal, objective: 5.013992307955561
    160 -- optimal, objective: 3.8398600172210555
    161 -- optimal, objective: 1.657681493601502
    162 -- optimal, objective: 0.41178378891279976
    163 -- optimal, objective: 2.040684602784253
    164 -- optimal, objective: 2.0029977728129347
    165 -- optimal, objective: 2.5114799236197083
    166 -- optimal, objective: 0.482589146520343
    167 -- optimal, objective: 3.8889766576130747
    168 -- optimal, objective: 1.076946530822019
    169 -- optimal, objective: 2.4991932008773934
    170 -- optimal, objective: 1.8451901671290658
    171 -- optimal, objective: 4.516240233108687
    172 -- optimal, objective: 3.7259498522238985
    173 -- optimal, objective: 1.9205975302187837
    174 -- optimal, objective: 1.604051376121633
    175 -- optimal, objective: 0.32970734900678306
    176 -- optimal, objective: 3.17730264076306
    177 -- optimal, objective: 4.892210628679246
    178 -- optimal, objective: 1.7344423667014435
    179 -- optimal, objective: 2.0930393922511814
    180 -- optimal, objective: 1.9821792611907076
    181 -- optimal, objective: 3.0950130851762765
    182 -- optimal, objective: 2.562542928308156
    183 -- optimal, objective: 6.469839914004995
    184 -- optimal, objective: 2.0674756021957847
    185 -- optimal, objective: 2.3845462972648024
    186 -- optimal, objective: 1.5119667475375826
    187 -- optimal, objective: 3.625376291000332
    188 -- optimal, objective: 0.9836491008702593
    189 -- optimal, objective: 1.9174021295224002
    190 -- optimal, objective: 1.0200049678541216
    191 -- optimal, objective: 1.8111147486376133
    192 -- optimal, objective: 10.407007486641513
    193 -- optimal, objective: 5.725212636472786
    194 -- optimal, objective: 6.585121023629433
    195 -- optimal, objective: 1.1403803946151112
    196 -- optimal, objective: 4.636496073473488
    197 -- optimal, objective: 3.9217711869841874
    198 -- optimal, objective: 1.0045702657467588
    199 -- optimal, objective: 2.4182154805461566
    200 -- optimal, objective: 2.9243580215268454
    201 -- optimal, objective: 2.968975837966427
    202 -- optimal, objective: 2.615284972310998
    203 -- optimal, objective: 2.49140911803088
    204 -- optimal, objective: 1.7943475942820328
    205 -- optimal, objective: 5.708286126986131
    206 -- optimal, objective: 2.4056024845433197
    207 -- optimal, objective: 0.9383328408601778
    208 -- optimal, objective: 4.7966629915068015
    209 -- optimal, objective: 0.5067734258626277
    210 -- optimal, objective: 2.1890884578826935
    211 -- optimal, objective: 3.216278312974742
    212 -- optimal, objective: 0.0796986618308498
    213 -- optimal, objective: 0.3907166988147716
    214 -- optimal, objective: 4.024001493666669
    215 -- optimal, objective: 3.594279949059035
    216 -- optimal, objective: 1.6777856827370754
    217 -- optimal, objective: 4.848031703923871
    218 -- optimal, objective: 0.48853441088520727
    219 -- optimal, objective: 12.374570705073896
    220 -- optimal, objective: 1.4284110604998381
    221 -- optimal, objective: 1.8180427493588949
    222 -- optimal, objective: 0.4850085026530658
    223 -- optimal, objective: 2.506785181047611
    224 -- optimal, objective: 1.397681298415294
    225 -- optimal, objective: 0.9031717605985932
    226 -- optimal, objective: 0.7285447496526384
    227 -- optimal, objective: 2.4703912751568806
    228 -- optimal, objective: 2.675134784731095
    229 -- optimal, objective: 3.3256746125806025
    230 -- optimal, objective: 2.5990372980386933
    231 -- optimal, objective: 4.837605778150171
    232 -- optimal, objective: 1.132923488341547
    233 -- optimal, objective: 1.6398399431865467
    234 -- optimal, objective: 3.008983350550686
    235 -- optimal, objective: 1.4124043086102738
    236 -- optimal, objective: 5.7719985153787485
    237 -- optimal, objective: 0.1493890601568216
    238 -- optimal, objective: 1.2057474878060594
    239 -- optimal, objective: 1.7168126471500427
    240 -- optimal, objective: 4.602217912756635
    241 -- optimal, objective: 2.1236291939626275
    242 -- optimal, objective: 2.531589994116896
    243 -- optimal, objective: 1.703140843014465
    244 -- optimal, objective: 2.217794001721053
    245 -- optimal, objective: 0.6465659506433485
    246 -- optimal, objective: 1.2916365175791173
    247 -- optimal, objective: 7.790245519815092
    248 -- optimal, objective: 1.060558078675598
    249 -- optimal, objective: 1.1515108837628771


.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function. Plot terminated.


