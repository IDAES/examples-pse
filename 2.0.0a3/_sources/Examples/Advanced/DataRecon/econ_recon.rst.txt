Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.core.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

====== ========= ========= ========== =
\      tag1      tag2      tag3       …
====== ========= ========= ========== =
index1 data(1,1) data(1,2) data(1, 3) …
index2 data(2,1) data(2,2) data(2, 3) …
…      …         …         …          …
====== ========= ========= ========== =

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

|       \| \| \| \| \|

\|——-|— —————|—————|——————-|—————————————————–\| \| tag1 \| model
reference 1 \| description 1 \| unit of measure 1 \| Additional
comments, additional columns are ignored \| \| tag2 \| model reference 2
\| description 2 \| unit of measure 2 \| … \| \| tag3 \| model reference
3 \| description 3 \| unit of measure 3 \| … \| \| … \| … \| … \| … \| …
\|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
“data_plot_book.pdf.”

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.power_generation.properties.flue_gas_ideal import FlueGasParameterBlock
    from idaes.generic_models.properties import iapws95
    from idaes.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        DeltaTMethod
    )
    import pyomo.environ as pyo


.. parsed-literal::

    WARNING: DEPRECATED: The properties package has been moved to
        idaes.models_extra.power_generation.properties  (deprecated in
        2.0.0.alpha0) (called from <frozen importlib._bootstrap>:219)
    WARNING: DEPRECATED: The flue_gas_ideal module has been moved to
        idaes.models_extra.power_generation.properties.flue_gas_ideal (deprecated
        in 2.0.0.alpha0) (called from <frozen importlib._bootstrap>:219)
    WARNING: DEPRECATED: The generic_models.properties.iapws95 has been moved to
        idaes.models.properties.iapws95  (deprecated in 2.0.0.alpha0) (called from
        <frozen importlib._bootstrap>:219)
    WARNING: DEPRECATED: The power_generation.unit_models package has been moved
        to idaes.models_extra.power_generation.unit_models  (deprecated in
        2.0.0.alpha0) (called from <frozen importlib._bootstrap>:219)
    WARNING: DEPRECATED: The boiler_heat_exchanger module has been moved to
        idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger
        (deprecated in 2.0.0.alpha0) (called from <frozen
        importlib._bootstrap>:219)


.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(default={"dynamic": False})
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(default={
            "side_1_property_package": m.fs.prop_water,
            "side_2_property_package": m.fs.prop_fluegas,
            "has_pressure_change": True,
            "has_holdup": False,
            "delta_T_method": DeltaTMethod.counterCurrent,
            "tube_arrangement": TubeArrangement.inLine,
            "side_1_water_phase": "Liq",
            "has_radiation": False
        }
    )


.. parsed-literal::

    WARNING: DEPRECATED: The default argument for the ProcessBlock class is
        deprecated. Arguments can now be passed directly as keyword arguments.
        (called from /tmp/ipykernel_2025/3112995203.py:3)
    2022-09-13 00:26:21 [WARNING] idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger: 'DeltaTMethod' is deprecated use 'HeatExchangerFlowPattern' This will be removed in IDAES 3.0
    WARNING: DEPRECATED: The default argument for the ProcessBlock class is
        deprecated. Arguments can now be passed directly as keyword arguments.
        (called from /tmp/ipykernel_2025/3112995203.py:7)
    2022-09-13 00:26:21 [WARNING] idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger: Config item delta_T_method is deprecated use flow_pattern. Will be removed in IDAES 3.0.
    2022-09-13 00:26:21 [WARNING] idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger: 'DeltaTMethod' is deprecated use 'HeatExchangerFlowPattern' This will be removed in IDAES 3.0
    2022-09-13 00:26:21 [WARNING] idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger: Config item side_1_property_package is deprecated. Will be removed in IDAES 3.0.
    2022-09-13 00:26:21 [WARNING] idaes.models_extra.power_generation.unit_models.boiler_heat_exchanger: Config item side_2_property_package is deprecated. Will be removed in IDAES 3.0.


.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = pyo.value(iapws95.htpx(563.706*pyo.units.K, 2.5449e7*pyo.units.Pa))
    
    m.fs.econ.side_1_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.side_1_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.side_1_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.side_2.properties_in[0].flow_mol_comp[c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.side_2_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.side_2_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.side_1_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.side_1_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.side_1_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.side_2_inlet.flow_mol_comp[0, "H2O"].value,
                "CO2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "CO2"].value,
                "N2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "N2"].value,
                "O2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "O2"].value,
                "NO": m.fs.econ.side_2_inlet.flow_mol_comp[0, "NO"].value,
                "SO2": m.fs.econ.side_2_inlet.flow_mol_comp[0, "SO2"].value,
            },
            "temperature": m.fs.econ.side_2_inlet.temperature[0].value,
            "pressure": m.fs.econ.side_2_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ.tube: Initialization Complete
    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ.shell.properties_in: Initialisation Complete, optimal - Optimal Solution Found.
    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ.shell.properties_out: Initialisation Complete, optimal - Optimal Solution Found.
    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ.shell.properties_out: fs.econ.shell.properties_out State Released.
    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ.shell: Initialization Complete
    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ: fs.econ Initialisation Step 1 Complete.
    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ.shell.properties_in: fs.econ.shell.properties_in State Released.
    2022-09-13 00:26:21 [INFO] idaes.init.fs.econ: fs.econ Initialisation Complete.


3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.  
    import idaes.core.util.tables as ta
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # this is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.side_1_inlet,
            "ECON_OUT": m.fs.econ.side_1_outlet,
            "FG_2_ECON": m.fs.econ.side_2_inlet,
            "FG_2_AIRPH": m.fs.econ.side_2_outlet,
        },
        sort=True,
    )
    
    # The next function converts the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ta.tag_state_quantities(
        blocks=state_dict, 
        attributes=(
            "flow_mass", 
            "flow_mol", 
            "enth_mol", 
            "temperature", 
            "pressure", 
            ("flow_mol_comp", "O2"),
            ("flow_mol_comp", "NO"),
            ("flow_mol_comp", "N2"),
            ("flow_mol_comp", "SO2"),
            ("flow_mol_comp", "CO2"),
            ("flow_mol_comp", "H2O"),
        ), 
        labels=("_Fm", "_F", "_h", "_T", "_P", "_F[O2]", "_F[NO]", "_F[N2]", "_F[SO2]", "_F[CO2]", "_F[H2O]"),
    )
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags["ECON_Q"] = m.fs.econ.heat_duty[0]

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.misc import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tags={"subtitle":"Initialized Model"})
        s = svg_tag(svg=s, tags=recon_tags, outfile="econ_init.svg")


.. parsed-literal::

    WARNING: DEPRECATED: idaes.core.util.misc.svg_tag has moved to
        idaes.core.util.tags.svg_tag  (deprecated in 1.12) (called from
        /home/runner/.conda/envs/idaes-env/lib/python3.8/site-
        packages/IPython/core/interactiveshell.py:3553)
    WARNING: DEPRECATED: svg_tag, the tags, tag_format and tag_format_default
        arguments are deprecated use tag_group instead.  (deprecated in 1.12)
        (called from /home/runner/.conda/envs/idaes-env/lib/python3.8/site-
        packages/idaes/core/util/misc.py:132)


.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.side_2.properties_in[0].flow_mol_comp[c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.side_1_inlet.unfix()
    m.fs.econ.side_2_inlet.unfix()
    m.fs.econ.side_1_outlet.unfix()
    m.fs.econ.side_2_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t])
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.1622227267478564
    1 -- optimal, objective: 0.819788154080471
    2 -- optimal, objective: 1.4704961756858985
    3 -- optimal, objective: 1.1898683973940773
    4 -- optimal, objective: 6.266875727768023
    5 -- optimal, objective: 2.353825037717308
    6 -- optimal, objective: 0.5232293871180635
    7 -- optimal, objective: 1.0234536307430038
    8 -- optimal, objective: 1.6923868337123509
    9 -- optimal, objective: 5.200179122889538
    10 -- optimal, objective: 2.0256916107502416
    11 -- optimal, objective: 1.3755108208586209
    12 -- optimal, objective: 1.8040192166109246
    13 -- optimal, objective: 1.0820617353511788
    14 -- optimal, objective: 2.872560865484769
    15 -- optimal, objective: 4.6793955509492084
    16 -- optimal, objective: 2.528560988157851
    17 -- optimal, objective: 3.4190895194025903
    18 -- optimal, objective: 0.6733418552016509
    19 -- optimal, objective: 1.3191361601576161
    20 -- optimal, objective: 2.5910945384684014
    21 -- optimal, objective: 0.728491791618803
    22 -- optimal, objective: 3.0961198470747084
    23 -- optimal, objective: 8.0469106121577
    24 -- optimal, objective: 9.434467872324587
    25 -- optimal, objective: 2.9086993281997
    26 -- optimal, objective: 5.764857210566877
    27 -- optimal, objective: 1.586991533853598
    28 -- optimal, objective: 0.984980863559903
    29 -- optimal, objective: 5.42071558243433
    30 -- optimal, objective: 0.15987321041189623
    31 -- optimal, objective: 1.9662708564309974
    32 -- optimal, objective: 4.631964135793727
    33 -- optimal, objective: 0.7898364826193097
    34 -- optimal, objective: 4.935317631382528
    35 -- optimal, objective: 2.7822547215128783
    36 -- optimal, objective: 3.7935585045919784
    37 -- optimal, objective: 7.3997278094156655
    38 -- optimal, objective: 1.8234865166601346
    39 -- optimal, objective: 8.12322419917884
    40 -- optimal, objective: 2.4669745912045267
    41 -- optimal, objective: 2.059014746274361
    42 -- optimal, objective: 4.82486032602039
    43 -- optimal, objective: 2.9053571960692115
    44 -- optimal, objective: 1.2573333384735599
    45 -- optimal, objective: 2.7626548687169104
    46 -- optimal, objective: 3.9105621874506915
    47 -- optimal, objective: 0.36385114388095996
    48 -- optimal, objective: 6.4820707513142235
    49 -- optimal, objective: 0.8862863572807849
    50 -- optimal, objective: 0.3533327138630483
    51 -- optimal, objective: 0.6741788395562354
    52 -- optimal, objective: 1.4465659660224106
    53 -- optimal, objective: 2.36571247767845
    54 -- optimal, objective: 1.4293043476044256
    55 -- optimal, objective: 11.608878616087667
    56 -- optimal, objective: 2.5845585218155596
    57 -- optimal, objective: 2.2280385889684022
    58 -- optimal, objective: 2.495375700856525
    59 -- optimal, objective: 1.6473059536498285
    60 -- optimal, objective: 8.02478299905107
    61 -- optimal, objective: 5.94357167964949
    62 -- optimal, objective: 2.335802980807595
    63 -- optimal, objective: 4.385136256674171
    64 -- optimal, objective: 0.5607930691618985
    65 -- optimal, objective: 2.1768732856567543
    66 -- optimal, objective: 2.8233151497317657
    67 -- optimal, objective: 4.396913088762334
    68 -- optimal, objective: 3.3918328175086225
    69 -- optimal, objective: 0.6148676050766855
    70 -- optimal, objective: 0.3708290390409561
    71 -- optimal, objective: 0.8762486395430988
    72 -- optimal, objective: 3.008624266411625
    73 -- optimal, objective: 6.178298889668569
    74 -- optimal, objective: 2.451581047869237
    75 -- optimal, objective: 8.974784736396618
    76 -- optimal, objective: 1.770689575522089
    77 -- optimal, objective: 3.126540074941454
    78 -- optimal, objective: 5.203571840723364
    79 -- optimal, objective: 4.7696215825017525
    80 -- optimal, objective: 4.816642172570763
    81 -- optimal, objective: 0.6532741094174032
    82 -- optimal, objective: 2.4965287219119383
    83 -- optimal, objective: 0.8032383968120528
    84 -- optimal, objective: 0.3628374751580307
    85 -- optimal, objective: 1.5238425496864703
    86 -- optimal, objective: 3.8657617083925198
    87 -- optimal, objective: 1.722267511980335
    88 -- optimal, objective: 3.9538723729634686
    89 -- optimal, objective: 1.6523626343497053
    90 -- optimal, objective: 3.3511000648602476
    91 -- optimal, objective: 1.2094028270637174
    92 -- optimal, objective: 1.5787041255816392
    93 -- optimal, objective: 3.410417173955489
    94 -- optimal, objective: 1.26388215166924
    95 -- optimal, objective: 3.2950211901073096
    96 -- optimal, objective: 1.5307192842206838
    97 -- optimal, objective: 2.0576184713663728
    98 -- optimal, objective: 1.7332046587098313
    99 -- optimal, objective: 4.588279410366771
    100 -- optimal, objective: 0.9293015277967163
    101 -- optimal, objective: 1.103546702583208
    102 -- optimal, objective: 0.005403092725190883
    103 -- optimal, objective: 4.030370198029125
    104 -- optimal, objective: 2.59778660742421
    105 -- optimal, objective: 3.718637539092343
    106 -- optimal, objective: 2.2200082219901387
    107 -- optimal, objective: 1.736160641358012
    108 -- optimal, objective: 1.7827907915253678
    109 -- optimal, objective: 0.8012179144634725
    110 -- optimal, objective: 0.489082201358194
    111 -- optimal, objective: 4.625444642903956
    112 -- optimal, objective: 4.073061803308481
    113 -- optimal, objective: 4.984149658953182
    114 -- optimal, objective: 4.5009037658422235
    115 -- optimal, objective: 0.8012381845209187
    116 -- optimal, objective: 2.6875543787763965
    117 -- optimal, objective: 6.864920838087289
    118 -- optimal, objective: 3.0375522321896513
    119 -- optimal, objective: 2.4940980097073346
    120 -- optimal, objective: 0.46083201829371695
    121 -- optimal, objective: 0.044472252223645696
    122 -- optimal, objective: 1.909211032156234
    123 -- optimal, objective: 4.153938460441787
    124 -- optimal, objective: 5.635804261323875
    125 -- optimal, objective: 4.7223994896017585
    126 -- optimal, objective: 4.837813299841435
    127 -- optimal, objective: 2.8953995802785215
    128 -- optimal, objective: 0.17007289875027495
    129 -- optimal, objective: 0.9837915670309216
    130 -- optimal, objective: 8.052254099295805
    131 -- optimal, objective: 6.2603162943050545
    132 -- optimal, objective: 2.572598330268907
    133 -- optimal, objective: 3.7332013380680378
    134 -- optimal, objective: 0.3400624609820704
    135 -- optimal, objective: 3.603316160958934
    136 -- optimal, objective: 2.5015730968089565
    137 -- optimal, objective: 0.3964042402966444
    138 -- optimal, objective: 0.14140350922429978
    139 -- optimal, objective: 8.317311777960532
    140 -- optimal, objective: 5.424431267918879
    141 -- optimal, objective: 2.8357421686723208
    142 -- optimal, objective: 1.5376013961507748
    143 -- optimal, objective: 3.6241963577006837
    144 -- optimal, objective: 4.954703626294975
    145 -- optimal, objective: 0.5851595630069797
    146 -- optimal, objective: 4.899572525361026
    147 -- optimal, objective: 3.6822688057449455
    148 -- optimal, objective: 2.121089843102047
    149 -- optimal, objective: 1.7199795815278756
    150 -- optimal, objective: 3.318912504228569
    151 -- optimal, objective: 0.3685078573133039
    152 -- optimal, objective: 1.9488329531202648
    153 -- optimal, objective: 2.6747680809659284
    154 -- optimal, objective: 7.585698103491925
    155 -- optimal, objective: 3.395738594834345
    156 -- optimal, objective: 4.149632062900691
    157 -- optimal, objective: 1.0001387519541214
    158 -- optimal, objective: 3.064483211734488
    159 -- optimal, objective: 5.014021556676835
    160 -- optimal, objective: 3.8398189061239165
    161 -- optimal, objective: 1.6576893499092917
    162 -- optimal, objective: 0.41176973979169107
    163 -- optimal, objective: 2.040678862856766
    164 -- optimal, objective: 2.002996344311849
    165 -- optimal, objective: 2.5115043865192135
    166 -- optimal, objective: 0.4825771049000274
    167 -- optimal, objective: 3.8889325125126666
    168 -- optimal, objective: 1.0769714540447919
    169 -- optimal, objective: 2.499194099134278
    170 -- optimal, objective: 1.845202288972045
    171 -- optimal, objective: 4.516275744333802
    172 -- optimal, objective: 3.7259845773038114
    173 -- optimal, objective: 1.9205831842368313
    174 -- optimal, objective: 1.6040433482387615
    175 -- optimal, objective: 0.329705992116411
    176 -- optimal, objective: 3.1773292559300823
    177 -- optimal, objective: 4.8922128737558195
    178 -- optimal, objective: 1.734421122212626
    179 -- optimal, objective: 2.0930113767060443
    180 -- optimal, objective: 1.9821944087033962
    181 -- optimal, objective: 3.0950639443599046
    182 -- optimal, objective: 2.5625165342163942
    183 -- optimal, objective: 6.469891429283253
    184 -- optimal, objective: 2.0674606386803567
    185 -- optimal, objective: 2.384535462236114
    186 -- optimal, objective: 1.5119923887476956
    187 -- optimal, objective: 3.6254181568250177
    188 -- optimal, objective: 0.9836625190091618
    189 -- optimal, objective: 1.9174184223606123
    190 -- optimal, objective: 1.0199853616406527
    191 -- optimal, objective: 1.8111192038560135
    192 -- optimal, objective: 10.407061899273792
    193 -- optimal, objective: 5.725243783933021
    194 -- optimal, objective: 6.5851885546311975
    195 -- optimal, objective: 1.1404034774868645
    196 -- optimal, objective: 4.636485739510356
    197 -- optimal, objective: 3.921803798658443
    198 -- optimal, objective: 1.0045607379024382
    199 -- optimal, objective: 2.4181948879174904
    200 -- optimal, objective: 2.924381439171096
    201 -- optimal, objective: 2.9689954757334656
    202 -- optimal, objective: 2.6152892965286134
    203 -- optimal, objective: 2.491418211244451
    204 -- optimal, objective: 1.7943475851127995
    205 -- optimal, objective: 5.708324626597069
    206 -- optimal, objective: 2.405605529769482
    207 -- optimal, objective: 0.9383160093489612
    208 -- optimal, objective: 4.796686075010915
    209 -- optimal, objective: 0.5067752382993014
    210 -- optimal, objective: 2.1890706011637984
    211 -- optimal, objective: 3.2162721207001304
    212 -- optimal, objective: 0.07970309825956079
    213 -- optimal, objective: 0.39071980305707793
    214 -- optimal, objective: 4.023971715053565
    215 -- optimal, objective: 3.5942477203080445
    216 -- optimal, objective: 1.677775501121007
    217 -- optimal, objective: 4.84803515440484
    218 -- optimal, objective: 0.48854638442714127
    219 -- optimal, objective: 12.374531482863256
    220 -- optimal, objective: 1.4283906796282415
    221 -- optimal, objective: 1.8180474372486684
    222 -- optimal, objective: 0.4850181471500437
    223 -- optimal, objective: 2.506770452120021
    224 -- optimal, objective: 1.3976831205728675
    225 -- optimal, objective: 0.9031827797634442
    226 -- optimal, objective: 0.7285597986983434
    227 -- optimal, objective: 2.470420726707453
    228 -- optimal, objective: 2.675098906685946
    229 -- optimal, objective: 3.3257056456054337
    230 -- optimal, objective: 2.5990527127801375
    231 -- optimal, objective: 4.837619200685995
    232 -- optimal, objective: 1.132937434663561
    233 -- optimal, objective: 1.6398640882823534
    234 -- optimal, objective: 3.0089508719252462
    235 -- optimal, objective: 1.4124059496646582
    236 -- optimal, objective: 5.771965407599033
    237 -- optimal, objective: 0.14938189272241248
    238 -- optimal, objective: 1.2057413172016678
    239 -- optimal, objective: 1.7168330910785947
    240 -- optimal, objective: 4.602205543920169
    241 -- optimal, objective: 2.1236311175232636
    242 -- optimal, objective: 2.531613551475053
    243 -- optimal, objective: 1.7031605794317939
    244 -- optimal, objective: 2.217789233310237
    245 -- optimal, objective: 0.6465633467363304
    246 -- optimal, objective: 1.2916378800473112
    247 -- optimal, objective: 7.789851988626152
    248 -- optimal, objective: 1.060573585612509
    249 -- optimal, objective: 1.151469126514078


.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function. Plot terminated.


