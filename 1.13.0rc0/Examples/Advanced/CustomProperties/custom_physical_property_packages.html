<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction to Property Packages in IDAES &mdash; IDAES v1.13.0rc0 Examples</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<!-- Add Google fonts -->
<link href="https://fonts.googleapis.com/css?family=Arimo|Roboto&display=swap"
      rel="stylesheet">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> IDAES Examples
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Tutorials/index.html">IDAES Tutorials</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">IDAES Examples</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Introduction to Property Packages in IDAES</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/Examples/Advanced/CustomProperties/custom_physical_property_packages.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="introduction-to-property-packages-in-idaes">
<h1>Introduction to Property Packages in IDAES<a class="headerlink" href="#introduction-to-property-packages-in-idaes" title="Permalink to this headline">¶</a></h1>
<p>Calculation of thermophysical, transport and reaction properties form a
key part of any process model, and it is important that these
calculations are both accurate and tractable in order for the overall
problem to be solved correctly. One of the features of the IDAES
Integrated Platform is the ability for modelers to create their own
property “packages” to calculate these properties, allowing them to
customize the level of complexity and rigor to suit each application.
This tutorial will introduce you to the basics of creating property
packages for calculating thermophysical and transport properties within
the IDAES Core Modeling Framework.</p>
<section id="what-is-a-property">
<h2>What is a Property?<a class="headerlink" href="#what-is-a-property" title="Permalink to this headline">¶</a></h2>
<p>Within the context of the IDAES Core Modeling Framework, a property is
considered to be any variable describing the state of a material at a
given point in space and time (both intensive and extensive), and
anything which can be calculated directly from the state variables. Some
common examples of properties include:</p>
<ul class="simple">
<li><p>material flowrates</p></li>
<li><p>material compositions (mass and/or mole fractions, concentrations,
etc.)</p></li>
<li><p>temperature</p></li>
<li><p>pressure</p></li>
<li><p>density and specific volume</p></li>
<li><p>specific heat capacity, enthalpy and entropy</p></li>
<li><p>phase equilibria</p></li>
<li><p>transport properties such as viscosity and thermal conductivity</p></li>
<li><p>rates of reaction and chemical equilibria</p></li>
</ul>
<p>The definition and calculation of all of these is defined via “property
packages”, which contain all the variables and constraints associated
with calculating these properties.</p>
<div class="alert alert-block alert-info docutils container">
<p>Note: It is important to emphasize that extensive flow information is
considered part of the material state within the IDAES Core Modeling
Framework. This is done to allow the framework to adapt to how the
material flow (e.g. by volumetric flow and concentrations, or molar
flow and mole fractions) is defined and automatically incorporate
this into the material, energy and momentum balances.</p>
</div>
</section>
<section id="how-are-properties-used">
<h2>How are Properties Used?<a class="headerlink" href="#how-are-properties-used" title="Permalink to this headline">¶</a></h2>
<p>Before we begin discussing how to build a property package, it is
important to understand where and how properties are used within the
greater modeling framework. Hopefully by now you are familiar with the
IDAES modeling hierarchy or flowsheets, unit models and state blocks.</p>
<p>A process <code class="docutils literal notranslate"><span class="pre">flowsheet</span></code> consists of a network of <code class="docutils literal notranslate"><span class="pre">unit</span> <span class="pre">models</span></code>
connected together by <code class="docutils literal notranslate"><span class="pre">Arcs</span></code> (i.e. streams). Each unit model contains
a set of material, energy and momentum balance equations as well as some
performance equations that describe how the unit behaves. Each of these
equations in turn depends on the properties of the material at some
point in the unit operations (generally an inlet or an outlet), and it
is here that the unit model calls upon a property package to obtain
these properties.</p>
<p>For each point in space and time included in the model, a <code class="docutils literal notranslate"><span class="pre">StateBlock</span></code>
is created which contains a full description of the material state
(i.e. the full set of necessary state variables), along with
calculations for all the properties required at that point. The
<code class="docutils literal notranslate"><span class="pre">unit</span> <span class="pre">model</span></code> (and <code class="docutils literal notranslate"><span class="pre">flowsheet</span></code>) can then refer to the property in
this <code class="docutils literal notranslate"><span class="pre">StateBlock</span></code> wherever it is required in a calculation.</p>
</section>
<section id="what-properties-do-i-need">
<h2>What Properties do I Need?<a class="headerlink" href="#what-properties-do-i-need" title="Permalink to this headline">¶</a></h2>
<p>An important aspect of the IDAES Core Modeling Framework is that a
modeler only needs to provide calculations for those properties that
they will use within their process. Put another way, modelers do not
need to include calculations for a property that they are not going to
use in their model – this allows modelers to avoid introducing
unnecessary complexity into their models to calculate a property they do
not actually need. When combined with flexibility elsewhere in the
modeling framework to control which equations are written in the unit
models, this can even allow users to avoid calculating properties that
would normally be considered mandatory – for example, a property package
for a conceptual design flowsheet which does not include energy or
momentum balances would not need to define specific enthalpy or even
temperature and pressure as these will not be required by the unit
models.</p>
<p>This then raises the question of how do you know what properties you
will need, especially if you are using models from a library you did not
write yourself. To answer this, you should refer to the model
documentation, and you can also use the <a class="reference external" href="https://idaes-pse.readthedocs.io/en/latest/technical_specs/model_libraries/generic/property_models/interrogator.html">IDAES Properties Interrogator
tool</a>
to analyze your flowsheet and determine what properties are required.</p>
</section>
<section id="thermophysical-properties-and-reaction-properties">
<h2>Thermophysical Properties and Reaction Properties<a class="headerlink" href="#thermophysical-properties-and-reaction-properties" title="Permalink to this headline">¶</a></h2>
<p>Within the IDAES Core Modeling Framework, properties are divided into
two classifications; thermophysical properties and reaction properties.
Reaction properties are those properties related to chemical reactions
(both equilibrium and rate-based, but not phase equilibrium) that occur
within the system , whilst thermophysical properties include those
properties related to thermodynamic relationships (including phase
equilibrium) and transport properties. The reason for this separation is
that thermophysical properties are required by all unit operations in a
process (and need to be consistent with each other), whilst reaction
properties are generally only required in specific unit operations
identified as “reactors” (and each reactor may have a different set of
chemical reactions occurring in it). Thus, reaction properties are
separated from the thermophysical property calculations to allow for
modular implementation in only specific reactor units. This tutorial
only deals with thermophysical properties, and reaction properties will
be dealt with in a later tutorial.</p>
</section>
<section id="what-is-a-property-package">
<h2>What is a Property “Package”?<a class="headerlink" href="#what-is-a-property-package" title="Permalink to this headline">¶</a></h2>
<p>Generally, properties (both thermophysical and reaction) are calculated
using correlations that depend on some set of parameters (be they
physical constants or empirical parameters). These parameters are
constant across all instances of a property calculation in a flowsheet
(i.e. each StateBlock uses the same parameters), it makes sense to store
these parameters in a single, central location that all StateBlocks can
refer to as necessary. Thus, the IDAES modeling framework has “Parameter
Blocks” which are attached to the flowsheet to contain all the global
parameters associated with a given set of property calculations.</p>
<p>Thus, the calculations of thermophysical properties within the IDAES
modeling framework is achieved using a “package” of three related
modeling components (or classes); the Physical Parameter Block, the
State Block and the State Block Data classes. Each of these will be
discussed further in the next section as we develop an example property
package.</p>
<p>At a deeper level, the calculation for many thermophysical properties is
a self-contained correlation that is more or less independent of the
other properties around it. Thus, each set of thermophysical property
calculations is a package of user-chosen sub-models for each property of
interest to the user.</p>
</section>
<section id="steps-in-creating-a-property-package">
<h2>Steps in Creating a Property Package<a class="headerlink" href="#steps-in-creating-a-property-package" title="Permalink to this headline">¶</a></h2>
<p>Creating a new property package can be broken down into the following
steps, which will be demonstrated in the next part of this tutorial.</p>
<ol class="arabic simple">
<li><p>Defining the <strong>units of measurement</strong> for the property package.</p></li>
<li><p>Defining the <strong>properties supported</strong> by the property package and the
associated metadata.</p></li>
<li><p>Defining the <strong>phases and components</strong> of interest.</p></li>
<li><p>Defining the necessary <strong>parameters</strong> required to calculate the
properties of interest.</p></li>
<li><p>Declaring the <strong>state variables</strong> to be used for the property
package.</p></li>
<li><p>Creating <strong>variables and constraints</strong> to describe the properties of
interest.</p></li>
<li><p>Creating an <strong>initialization routine</strong> for the property package.</p></li>
<li><p>Defining <strong>interface methods</strong> used to couple the property package
with unit models.</p></li>
</ol>
</section>
</section>
<section id="tutorial-example">
<h1>Tutorial Example<a class="headerlink" href="#tutorial-example" title="Permalink to this headline">¶</a></h1>
<p>For this tutorial, we will be building a simple property package that
could be used to model a process for the hydrodealkylation of toluene to
form benzene. This process involves five key chemical species:</p>
<ul class="simple">
<li><p>toluene</p></li>
<li><p>benzene</p></li>
<li><p>hydrogen</p></li>
<li><p>methane</p></li>
<li><p>diphenyl</p></li>
</ul>
<p>The process also involves two reactions; a primary reaction of toluene
and hydrogen reacting to form benzene and methane and a secondary
reaction of benzene reacting to form diphenyl and hydrogen. These
reactions occur within the vapor phase at high temperatures, however
vapor-liquid equilibrium is used to separate the benzene product from
the toluene and diphenyl. For this tutorial however, we will focus only
on the vapor phase as implementing the equations for vapor-liquid
equilibrium requires a separate tutorial of its own. Additionally, as
this tutorial is only looking at writing the thermophysical property
package, we do not need to concern our selves with the reaction
properties (this will be the subject of another tutorial).</p>
<p>For this tutorial we will use total molar flowrate, component mole
fractions, temperature and pressure as the state variables, and
implement methods to calculate the following properties using the
assumption of ideal gas behavior;</p>
<ul class="simple">
<li><p>molecular weight of each component</p></li>
<li><p>density of the mixture using the ideal gas equation</p></li>
<li><p>specific enthalpy of the mixture using the equations from “The
Properties of Gases and Liquids 4th edition”, by Reid, Prausnitz and
Polling (1987).</p></li>
</ul>
<p>This is a rather limited set of properties, but it is sufficient to
demonstrate the different ways that properties can be implemented and to
solve a simple example. Users can implement additional properties as
required using these as examples.</p>
<section id="a-note-on-this-tutorial">
<h2>A Note on this Tutorial<a class="headerlink" href="#a-note-on-this-tutorial" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">build</span></code> methods in the property package classes are generally
written as a single, long method. However, to break the code into
manageable pieces for discussion, in this tutorial we will create a
number of smaller sub-methods that will then be called as part of the
<code class="docutils literal notranslate"><span class="pre">build</span></code> method. This is done entirely for presentation purposes, and
model developers should not feel compelled to write their models this
way.</p>
<p>An example of how the example in this tutorial would be written without
sub-methods can be found in the same folder with the name
<code class="docutils literal notranslate"><span class="pre">thermophysical_property_example.py</span></code>.</p>
</section>
<section id="components-of-a-property-package">
<h2>Components of a Property Package<a class="headerlink" href="#components-of-a-property-package" title="Permalink to this headline">¶</a></h2>
<p>As mentioned previously, thermophysical property packages consist of
three parts, which are written as Python <code class="docutils literal notranslate"><span class="pre">classes</span></code>. These components
are:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Physical</span> <span class="pre">Parameter</span> <span class="pre">Block</span></code> class, which contains all the global
parameters associated with the property package,</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span> <span class="pre">Data</span></code> class, which contains the instructions on
how to calculate all the properties at a given state, and,</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> class, which is used to construct indexed sets of
<code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span> <span class="pre">Data</span></code> objects and contains methods for acting on all
multiple <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span> <span class="pre">Data</span></code> objects at once (such as
initialization).</p></li>
</ul>
<p>It is not necessary to understand the reason for the distinction between
the <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> and <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span> <span class="pre">Data</span></code> classes. Suffice to say
that this is due to the need to replicate the underlying component
structure of Pyomo, and that the <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> represents the indexed
<code class="docutils literal notranslate"><span class="pre">Block</span></code> representing a set of states across a given indexing set (most
often time), and the <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span> <span class="pre">Data</span></code> represents the individual
elements of the indexed <code class="docutils literal notranslate"><span class="pre">Block</span></code>.</p>
</section>
<section id="importing-libraries">
<h2>Importing Libraries<a class="headerlink" href="#importing-libraries" title="Permalink to this headline">¶</a></h2>
<p>Before we begin writing the actual <code class="docutils literal notranslate"><span class="pre">classes</span></code> however, we need to
import all the necessary components from the Pyomo and IDAES modeling
libraries. To begin with, we are going to need a number of components
from the Pyomo modeling environment to construct the variables,
constraints and parameters that will make up the property package, and
we will also make use of the Pyomo units of measurement tools to define
the units of our properties. We will also make use of a number of
components and supporting methods from the IDAES modeling framework and
libraries.</p>
<p>Rather than describe the purpose of all of these here, we shall just
import all of them here and discuss their use as they arise in the
example.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import components from Pyomo</span>
<span class="kn">from</span> <span class="nn">pyomo.environ</span> <span class="kn">import</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">Reference</span><span class="p">,</span> <span class="n">Param</span><span class="p">,</span> <span class="n">units</span> <span class="k">as</span> <span class="n">pyunits</span><span class="p">,</span> <span class="n">Var</span>

<span class="c1"># Import IDAES cores</span>
<span class="kn">from</span> <span class="nn">idaes.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">declare_process_block_class</span><span class="p">,</span>
                        <span class="n">MaterialFlowBasis</span><span class="p">,</span>
                        <span class="n">PhysicalParameterBlock</span><span class="p">,</span>
                        <span class="n">StateBlockData</span><span class="p">,</span>
                        <span class="n">StateBlock</span><span class="p">,</span>
                        <span class="n">MaterialBalanceType</span><span class="p">,</span>
                        <span class="n">EnergyBalanceType</span><span class="p">,</span>
                        <span class="n">Component</span><span class="p">,</span>
                        <span class="n">VaporPhase</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">idaes.core.util</span> <span class="kn">import</span> <span class="n">get_solver</span>
<span class="kn">from</span> <span class="nn">idaes.core.util.initialization</span> <span class="kn">import</span> <span class="p">(</span><span class="n">fix_state_vars</span><span class="p">,</span>
                                            <span class="n">revert_state_vars</span><span class="p">,</span>
                                            <span class="n">solve_indexed_blocks</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">idaes.core.util.model_statistics</span> <span class="kn">import</span> <span class="n">degrees_of_freedom</span><span class="p">,</span> \
                                             <span class="n">number_unfixed_variables</span>
<span class="kn">from</span> <span class="nn">idaes.core.util.constants</span> <span class="kn">import</span> <span class="n">Constants</span> <span class="k">as</span> <span class="n">const</span>
<span class="kn">import</span> <span class="nn">idaes.logger</span> <span class="k">as</span> <span class="nn">idaeslog</span>
</pre></div>
</div>
</section>
</section>
<section id="the-physical-parameter-block">
<h1>The Physical Parameter Block<a class="headerlink" href="#the-physical-parameter-block" title="Permalink to this headline">¶</a></h1>
<p>We will begin by constructing the <code class="docutils literal notranslate"><span class="pre">Physical</span> <span class="pre">Parameter</span> <span class="pre">Block</span></code> for our
property example. This serves as the central point of reference for all
aspects of the property package, and needs to define a number of things
about the package. These are summarized below:</p>
<ul class="simple">
<li><p>Units of measurement</p></li>
<li><p>What properties are supported and how they are implemented</p></li>
<li><p>What components and phases are included in the packages</p></li>
<li><p>All the global parameters necessary for calculating properties</p></li>
<li><p>A reference to the associated <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> class, so that
construction of the <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> components can be automated from
the <code class="docutils literal notranslate"><span class="pre">Physical</span> <span class="pre">Parameter</span> <span class="pre">Block</span></code></p></li>
</ul>
<section id="step-1-define-units-of-measurement">
<h2>Step 1: Define Units of Measurement<a class="headerlink" href="#step-1-define-units-of-measurement" title="Permalink to this headline">¶</a></h2>
<p>The first step is to define the units of measurement for the property
package, which will in turn be inherited by any unit model using this
property package. Units of measurement for the property package are
defined by setting units for the 7 base measurement quantities; time,
length, mass, amount, temperature, current and luminous intensity (as
current and luminous intensity are generally of lesser importance in
process systems engineering, specifying units for these base quantities
is optional). Within IDAES, units are specified using Pyomo’s units of
measurement features, which can be imported from <code class="docutils literal notranslate"><span class="pre">pyomo.environ</span></code>. For
this example, the units of measurement features were given the name
<code class="docutils literal notranslate"><span class="pre">pyunits</span></code> for clarity.</p>
<p>The units of measurement for all other quantities in the model can then
be derived from these base quantities; for example the units of energy
are <code class="docutils literal notranslate"><span class="pre">mass*length^2/time^2</span></code>. The framework expects all quantities in
the property package to use these base units – the Pyomo units of
measurement conversion tools can be used if conversion between different
sets of units are required.</p>
<p>In order to set the base units, we need to create a dictionary which has
each of the base quantities as a key, and provide a Pyomo recognized
unit as the value as shown below.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">units_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                  <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                  <span class="s1">&#39;mass&#39;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="p">,</span>
                  <span class="s1">&#39;amount&#39;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span>
                  <span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step-2-define-supported-properties">
<h2>Step 2: Define Supported Properties<a class="headerlink" href="#step-2-define-supported-properties" title="Permalink to this headline">¶</a></h2>
<p>The next step is to provide some metadata defining what properties are
supported by the property package (including state variables). The first
purpose of this metadata is to record a summary of what properties are
supported to help user identify whether a given property package is
suitable for their needs. The second purpose of the metadata is to allow
us to simplify our property calculations by only construction those
properties that are actually required by a given unit operation – a
property package needs to support all the properties required by a
process flowsheet, but not all of those properties are required in every
unit operation. Thus, the IDAES modeling framework supports a
“build-on-demand” approach for properties, such that only those
properties that are required are constructed at any given point.</p>
<p>This is achieved through the use of the properties metadata, where for
each property supported by the property package the user needs to define
a <code class="docutils literal notranslate"><span class="pre">method</span></code> argument. This argument can take one of two forms:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> indicates that the specified property is always constructed
by the property package (as part of the <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span> <span class="pre">Data</span></code>
<code class="docutils literal notranslate"><span class="pre">build</span></code> method), and that if it can not be found then something has
gone wrong. These types of properties would typically be the state
variables (which must always be constructed), and any property that
is expected to be used in most unit operations (such as specific
enthalpy that will likely be used in the energy balances).</p></li>
<li><p>for those properties that should only be constructed when required,
the <code class="docutils literal notranslate"><span class="pre">method</span></code> argument should be the name of a method in the
<code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span> <span class="pre">Data</span></code> class (as a string) which contains the
instructions on building the necessary variables, expressions and
constraints for calculating this property. If a unit model calls for
this property and it has not been constructed yet, this method will
be called in order to construct it.</p></li>
</ul>
<p>In this tutorial, we will demonstrate both approaches (users can freely
mix both approaches to suit their needs). For this example, the state
variables, molecular weight and density calculations will be constructed
for all states, whilst the molar enthalpy calculations will be
built-on-demand. The cell, below shows the property metadata dictionary
for this example - note that the method for <code class="docutils literal notranslate"><span class="pre">enth_mol</span></code> is a string
which refers to a method we will construct later).</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">properties_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;flow_mol&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                       <span class="s1">&#39;mole_frac_comp&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                       <span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                       <span class="s1">&#39;pressure&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                       <span class="s1">&#39;mw_comp&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                       <span class="s1">&#39;dens_mol&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                       <span class="s1">&#39;enth_mol&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;_enth_mol&#39;</span><span class="p">}}</span>
</pre></div>
</div>
</section>
<section id="step-3-define-component-and-phase-lists">
<h2>Step 3: Define Component and Phase Lists<a class="headerlink" href="#step-3-define-component-and-phase-lists" title="Permalink to this headline">¶</a></h2>
<p>The next step in writing the Physical Parameter Block class is to define
the phases and components present in the mixture. These are defined
using <code class="docutils literal notranslate"><span class="pre">Phase</span></code> and <code class="docutils literal notranslate"><span class="pre">Component</span></code> objects which are imported from
<code class="docutils literal notranslate"><span class="pre">idaes.core</span></code>. As <code class="docutils literal notranslate"><span class="pre">Phase</span></code> and <code class="docutils literal notranslate"><span class="pre">Component</span></code> objects are added to the
proeprty package, the <code class="docutils literal notranslate"><span class="pre">phase_list</span></code> and <code class="docutils literal notranslate"><span class="pre">component_list</span></code> <code class="docutils literal notranslate"><span class="pre">Sets</span></code>
required by the modeling framework are automatically populated. Even for
systems where there is only a single phase or component, it is necessary
to define phase and component objects as these are used to construct the
necessary indexing sets used when building unit models.</p>
<p>For this example, we have 5 components of interest; benzene, toluene,
hydrogen, methane and diphenyl. We define these in the property package
by adding a generic <code class="docutils literal notranslate"><span class="pre">Component</span></code> object to the Physical Parameter
Block; for example <code class="docutils literal notranslate"><span class="pre">self.benzene</span> <span class="pre">=</span> <span class="pre">Component()</span></code>. For more complex
systems, IDAES supports a number of different component types and
components can be assigned a number of arguments at constructions but
these will not be discussed here.</p>
<p>Similarly, we also need to define the phases of interest in our system;
in this case we have a single vapor phase. IDAES supports a number of
different phase types, and the choice of phase type is used to determine
how a phase behaves when a phase separation occurs. For example, in a
flash separator, all vapor phases exit via the vapor outlet whilst all
other phases exit via the liquid outlet. For this example, we add a
single <code class="docutils literal notranslate"><span class="pre">VaporPhase</span></code> object to the Physical Parameter Block wit the
name <code class="docutils literal notranslate"><span class="pre">Vap</span></code> as shown below.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">define_components_and_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Define Component objects for all species</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">benzene</span> <span class="o">=</span> <span class="n">Component</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">toluene</span> <span class="o">=</span> <span class="n">Component</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">methane</span> <span class="o">=</span> <span class="n">Component</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hydrogen</span> <span class="o">=</span> <span class="n">Component</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">diphenyl</span> <span class="o">=</span> <span class="n">Component</span><span class="p">()</span>

    <span class="c1"># Define Phase objects for all phases</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Vap</span> <span class="o">=</span> <span class="n">VaporPhase</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="step-4-define-parameters">
<h2>Step 4: Define Parameters<a class="headerlink" href="#step-4-define-parameters" title="Permalink to this headline">¶</a></h2>
<p>Once the phases and components of interest have been defined, the next
step is to begin defining the parameters necessary for the property
calculations.</p>
<div class="alert alert-block alert-info docutils container">
<p>Param or Var:</p>
<p>The most obvious way to declare a “parameter” in a model would appear
to be to use the Pyomo <code class="docutils literal notranslate"><span class="pre">Param</span></code> object. However, modelers should be
aware the <code class="docutils literal notranslate"><span class="pre">Param</span></code> objects are never seen by the solver (they are
converted to fixed floating point numbers by the solver writer). This
means that it is not possible to use a solver to find the value for a
parameter – i.e., it is not possible to use <code class="docutils literal notranslate"><span class="pre">Param</span></code> objects in a
parameter estimation problem.</p>
<p>Instead, modelers should use fixed <code class="docutils literal notranslate"><span class="pre">Var</span></code> objects for any parameter
that may need to be estimated at some point. Within IDAES, this means
that most “parameters” are in fact declared as <code class="docutils literal notranslate"><span class="pre">Var</span></code> objects, with
<code class="docutils literal notranslate"><span class="pre">Param</span></code> objects used only for parameters with well-known values
(for example critical pressures and temperatures or molecular
weights).</p>
</div>
<p>For this example, the first parameters we need to define are the
reference state for our property calculations along with the molecular
weights of each of the components of interest. These are fixed
parameters that should not be estimated by parameter estimation, so we
create Pyomo <code class="docutils literal notranslate"><span class="pre">Param</span></code> objects to represent each of these, as shown
below. When we declare a <code class="docutils literal notranslate"><span class="pre">Param</span></code>, we also need to define a default
value and the units of measurement for each parameter. Note that the
units of measurement for these parameters does not necessarily need to
match those defined in the properties metadata, but if they are not
consistent then a unit conversion will be required at some point when
calculating property values.</p>
<p>Within the IDAES Modeling Libraries, we generally define parameters and
property calculations in the units of the source material, and then
convert the calculated value into the desired units of measurement for
the property package. This is done to minimize the chance of mistakes
when entering parameter values as they can be taken directly from the
source material. For example, Antoine coefficients are generally defined
in units of bar and Kelvins and the calculation for saturation pressure
is performed in these units with only the final value for saturation
pressure converted to the desired units for pressure.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">define_basic_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Thermodynamic reference state</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pressure_ref</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">default</span><span class="o">=</span><span class="mi">101325</span><span class="p">,</span>
                              <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">Pa</span><span class="p">,</span>
                              <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Reference pressure&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">temperature_ref</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">default</span><span class="o">=</span><span class="mf">298.15</span><span class="p">,</span>
                                <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">,</span>
                                <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Reference temperature&#39;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">mw_comp</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">,</span>
                        <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">initialize</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;benzene&#39;</span><span class="p">:</span> <span class="mf">78.1136E-3</span><span class="p">,</span>
                                    <span class="s1">&#39;toluene&#39;</span><span class="p">:</span> <span class="mf">92.1405E-3</span><span class="p">,</span>
                                    <span class="s1">&#39;hydrogen&#39;</span><span class="p">:</span> <span class="mf">2.016e-3</span><span class="p">,</span>
                                    <span class="s1">&#39;methane&#39;</span><span class="p">:</span> <span class="mf">16.043e-3</span><span class="p">,</span>
                                    <span class="s1">&#39;diphenyl&#39;</span><span class="p">:</span> <span class="mf">154.212e-4</span><span class="p">},</span>
                        <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Molecular weight&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For this example, we also need to define the parameter associated with
calculating the specific enthalpy of each component. As mentioned
before, we will use the correlation proposed in “The Properties of Gases
and Liquids, 4th Edition” by Reid, Prausnitz and Polling (1987), which
has the form:</p>
<p><a href="#id1"><span class="problematic" id="id2">:raw-latex:`\begin{equation*}
h_j – h_{j, ref}= A_j \times (T-T_{ref}) + \frac{B_j}{2}\times (T^2-T_{ref}^2) + \frac{C_j}{3}\times (T^3-T_{ref}^3) + \frac{D_j}{4}\times (T^4-T_{ref}^4)
\end{equation*}`</span></a></p>
<p>where <span class="math notranslate nohighlight">\(h_{j, ref}\)</span> is the standard heat of formation of component
<span class="math notranslate nohighlight">\(j\)</span> in the vapor phase, and <span class="math notranslate nohighlight">\(A_j\)</span>, <span class="math notranslate nohighlight">\(B_j\)</span>, <span class="math notranslate nohighlight">\(C_j\)</span>,
and <span class="math notranslate nohighlight">\(D_j\)</span> are component-specific parameters in the correlation. At
first glance, one might ask if we could declare a single object indexed
by the list <code class="docutils literal notranslate"><span class="pre">[“A”,</span> <span class="pre">“B”,</span> <span class="pre">“C”,</span> <span class="pre">“D”]</span></code> and component to represent all the
parameters as a single object; however it must be noted that the
parameters <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(C\)</span>, and <span class="math notranslate nohighlight">\(D\)</span> all have
different units. Thus, we need to declare separate objects for each of
<span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(C\)</span>, and <span class="math notranslate nohighlight">\(D\)</span> (along with
<span class="math notranslate nohighlight">\(h_{ref}\)</span>) which are indexed by component so that we can assign
the correct units to each.</p>
<p>However, these parameters are mostly empirical and are values that we
may wish to estimate at some point, thus we will declare these as Pyomo
<code class="docutils literal notranslate"><span class="pre">Var</span></code> objects rather than <code class="docutils literal notranslate"><span class="pre">Param</span></code> objects, which also means that we
must <code class="docutils literal notranslate"><span class="pre">fix</span></code> the value of these parameters when we construct the
property package. This is shown in the code below – note that each
parameters (<code class="docutils literal notranslate"><span class="pre">Var</span></code> object is fixed immediately after it is declared).</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">define_specific_heat_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Constants for specific heat capacity, enthalpy</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_A</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">,</span>
            <span class="n">initialize</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;benzene&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">3.392E1</span><span class="p">,</span>
                        <span class="s2">&quot;toluene&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">2.435E1</span><span class="p">,</span>
                        <span class="s2">&quot;hydrogen&quot;</span><span class="p">:</span> <span class="mf">2.714e1</span><span class="p">,</span>
                        <span class="s2">&quot;methane&quot;</span><span class="p">:</span> <span class="mf">1.925e1</span><span class="p">,</span>
                        <span class="s2">&quot;diphenyl&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">9.707e1</span><span class="p">},</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Parameter A for ideal gas molar heat capacity&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_A</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_B</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">,</span>
            <span class="n">initialize</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;benzene&quot;</span><span class="p">:</span> <span class="mf">4.739E-1</span><span class="p">,</span>
                        <span class="s2">&quot;toluene&quot;</span><span class="p">:</span> <span class="mf">5.125E-1</span><span class="p">,</span>
                        <span class="s2">&quot;hydrogen&quot;</span><span class="p">:</span> <span class="mf">9.274e-3</span><span class="p">,</span>
                        <span class="s2">&quot;methane&quot;</span><span class="p">:</span> <span class="mf">5.213e-2</span><span class="p">,</span>
                        <span class="s2">&quot;diphenyl&quot;</span><span class="p">:</span> <span class="mf">1.106e0</span><span class="p">},</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Parameter B for ideal gas molar heat capacity&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_B</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_C</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">,</span>
            <span class="n">initialize</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;benzene&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">3.017E-4</span><span class="p">,</span>
                        <span class="s2">&quot;toluene&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">2.765E-4</span><span class="p">,</span>
                        <span class="s2">&quot;hydrogen&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.381e-5</span><span class="p">,</span>
                        <span class="s2">&quot;methane&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">8.855e-4</span><span class="p">,</span>
                        <span class="s2">&quot;diphenyl&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">8.855e-4</span><span class="p">},</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Parameter C for ideal gas molar heat capacity&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_C</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_D</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">,</span>
            <span class="n">initialize</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;benzene&quot;</span><span class="p">:</span> <span class="mf">7.130E-8</span><span class="p">,</span>
                        <span class="s2">&quot;toluene&quot;</span><span class="p">:</span> <span class="mf">4.911E-8</span><span class="p">,</span>
                        <span class="s2">&quot;hydrogen&quot;</span><span class="p">:</span> <span class="mf">7.645e-9</span><span class="p">,</span>
                        <span class="s2">&quot;methane&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.132e-8</span><span class="p">,</span>
                        <span class="s2">&quot;diphenyl&quot;</span><span class="p">:</span> <span class="mf">2.790e-7</span><span class="p">},</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Parameter D for ideal gas molar heat capacity&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_D</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">enth_mol_form_vap_comp_ref</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">,</span>
            <span class="n">initialize</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;benzene&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">82.9e3</span><span class="p">,</span>
                        <span class="s2">&quot;toluene&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">50.1e3</span><span class="p">,</span>
                        <span class="s2">&quot;hydrogen&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="s2">&quot;methane&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">75e3</span><span class="p">,</span>
                        <span class="s2">&quot;diphenyl&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">180e3</span><span class="p">},</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Standard heat of formation at reference state&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">enth_mol_form_vap_comp_ref</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="declaring-the-physical-parameter-block">
<h2>Declaring the Physical Parameter Block<a class="headerlink" href="#declaring-the-physical-parameter-block" title="Permalink to this headline">¶</a></h2>
<p>Now that the various parts of the Physical Parameter Block have been
declared, we can assemble the actual <code class="docutils literal notranslate"><span class="pre">class</span></code> that will assemble these
components in a flowsheet. There are four parts to declaring our new
<code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> class, which are:</p>
<ol class="arabic simple">
<li><p>Declaring the new class and inheriting from the
<code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> base class</p></li>
<li><p>Declaring any necessary configuration arguments</p></li>
<li><p>Writing the <code class="docutils literal notranslate"><span class="pre">build</span></code> method for our <code class="docutils literal notranslate"><span class="pre">class</span></code></p></li>
<li><p>Creating a <code class="docutils literal notranslate"><span class="pre">define_metadata</span></code> method for the class.</p></li>
</ol>
<p>Each of these steps are shown in the code example below.</p>
<p>First, we need to declare our new class and give it a unique name. In
this example, we will call our new class <code class="docutils literal notranslate"><span class="pre">HDAParameterBlock</span></code>. The
first two lines of the example below show how we declare our new class
using the <code class="docutils literal notranslate"><span class="pre">declare_process_block_decorator</span></code> and inheriting from the
<code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> base class from the IDAES Core model
libraries. Inheriting from the <code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> brings us
access to all the necessary features required by the IDAES modeling
framework, whilst the <code class="docutils literal notranslate"><span class="pre">declare_process_block_class</span></code> decorator performs
some boilerplate operations to replicate the expected object structure
of Pyomo. Further details on these components can be found in the IDAES
documentation.</p>
<p>Next, we need to set up any configuration arguments we need for the
property package. This is done using Pyomo “Config Blocks” which provide
a convenient way of declaring, organizing and documenting configuration
arguments. To begin with, we can inherit from the <code class="docutils literal notranslate"><span class="pre">CONFIG</span></code> block
declared in the <code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> base class, which provides
all the arguments that the IDAES modeling framework expects to be
present. Modelers can then add additional configuration arguments to
provide users with options when constructing their property packages,
however we will not cover that in this tutorial.</p>
<p>The most significant part of any IDAES model class is the <code class="docutils literal notranslate"><span class="pre">build</span></code>
method, which contains the instructions on how to construct an instance
of the desired model and all IDAES models are expected to have a
<code class="docutils literal notranslate"><span class="pre">build</span></code> method. The first step in any <code class="docutils literal notranslate"><span class="pre">build</span></code> method is to call
<code class="docutils literal notranslate"><span class="pre">super().build()</span></code>, which will trigger the <code class="docutils literal notranslate"><span class="pre">build</span></code> method of the base
class that the current class inherits from – this is important since
this is how we automate construction of any underlying components
required by the modeling framework and ensure that everything integrates
smoothly. Next, a <code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> needs to contain a pointer
to the related <code class="docutils literal notranslate"><span class="pre">StateBlock</span></code> (which we will look at next) – this is
used to allow us to build instances of the <code class="docutils literal notranslate"><span class="pre">StateBlock</span></code> by only
knowing the <code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> we wish to use. To do this, we
create an attribute named <code class="docutils literal notranslate"><span class="pre">_state_block_class</span></code> attached to our class
with a pointer to the <code class="docutils literal notranslate"><span class="pre">StateBlock</span></code> class; in this case
<code class="docutils literal notranslate"><span class="pre">self._state_block_class</span> <span class="pre">=</span> <span class="pre">HDAStateBlock</span></code>, where <code class="docutils literal notranslate"><span class="pre">HDAStateBlock</span></code> is
the name of the yet to be declared <code class="docutils literal notranslate"><span class="pre">StateBlock</span></code>. Finally, the
<code class="docutils literal notranslate"><span class="pre">build</span></code> method needs to construct the actual parameters required for
the property package, which we do here by calling the sub-methods
written previously.</p>
<p>The final step in creating the <code class="docutils literal notranslate"><span class="pre">PhysicalParameterBlock</span></code> class is to
declare a <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> named <code class="docutils literal notranslate"><span class="pre">define_metadata</span></code> which takes two
arguments; a class (<code class="docutils literal notranslate"><span class="pre">cls</span></code>) and an instance of that class (<code class="docutils literal notranslate"><span class="pre">obj</span></code>).
This method in turn needs to call two pre-defined methods (inherited
from the underlying base classes):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj.add_properties()</span></code> is used to set the metadata regarding the
supported properties, and here we pass the <code class="docutils literal notranslate"><span class="pre">properties_metadata</span></code>
dict we created earlier as an argument.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obj.add_default_units()</span></code> sets the default units metadata for the
property package, and here we pass the <code class="docutils literal notranslate"><span class="pre">units_metadata</span></code> <code class="docutils literal notranslate"><span class="pre">dict</span></code> we
created earlier as an argument.</p></li>
</ul>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@declare_process_block_class</span><span class="p">(</span><span class="s2">&quot;HDAParameterBlock&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">HDAParameterData</span><span class="p">(</span><span class="n">PhysicalParameterBlock</span><span class="p">):</span>
    <span class="n">CONFIG</span> <span class="o">=</span> <span class="n">PhysicalParameterBlock</span><span class="o">.</span><span class="n">CONFIG</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Callable method for Block construction.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HDAParameterData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state_block_class</span> <span class="o">=</span> <span class="n">HDAStateBlock</span>

        <span class="n">define_components_and_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">define_basic_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">define_specific_heat_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">define_metadata</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define properties supported and units.&quot;&quot;&quot;</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">properties_metadata</span><span class="p">)</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">add_default_units</span><span class="p">(</span><span class="n">units_metadata</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="state-block">
<h1>State Block<a class="headerlink" href="#state-block" title="Permalink to this headline">¶</a></h1>
<p>After the <code class="docutils literal notranslate"><span class="pre">Physical</span> <span class="pre">Parameter</span> <span class="pre">Block</span></code> class has been created, the next
step is to write the code necessary to create the State Blocks that will
be used through out the flowsheet. Unlike other models however, creating
a <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> actually required us to write two <code class="docutils literal notranslate"><span class="pre">classes</span></code>. In
short, indexed Pyomo object components (e.g. <code class="docutils literal notranslate"><span class="pre">Vars</span></code> and <code class="docutils literal notranslate"><span class="pre">Blocks</span></code>)
actually consist of two objects: an <code class="docutils literal notranslate"><span class="pre">IndexedComponent</span></code> object which
serves as a container for multiple <code class="docutils literal notranslate"><span class="pre">ComponentData</span></code> objects which
represent the component at each point in the indexing set. For example,
a <code class="docutils literal notranslate"><span class="pre">Var</span></code> indexed by the <code class="docutils literal notranslate"><span class="pre">Set</span></code> <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code> actually consists of a
single <code class="docutils literal notranslate"><span class="pre">IndexedVar</span></code> object which contains 4 <code class="docutils literal notranslate"><span class="pre">VarData</span></code> objects.
Normally this behavior is hidden behind the
<code class="docutils literal notranslate"><span class="pre">declare_process_block_data</span></code> decorator which handles the details of
this structure (as a side note, unindexed components similarly involve
two classes but this is hidden by the use of multiple inheritance.)</p>
<p>Normally, when we write models in IDAES, we are concerned only with the
<code class="docutils literal notranslate"><span class="pre">ComponentData</span></code> object – i.e., the instructions on how to build an
instance of the model at each indexed point (hence the naming convention
used when declaring classes). However, State Blocks are slightly
different in that we always expect State Blocks to be indexed (they will
always be indexed by time, at a minimum). Due to this, we often want to
perform actions on all the elements of the indexed <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> at
once (rather than element by element), such as during initialization.
Thus, we have a need to write methods that are attached to the
<code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code> in addition to the normal methods for the
<code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> object. Fortunately, the
<code class="docutils literal notranslate"><span class="pre">declare_process_block_data</span></code> decorator facilitates this for us, but it
does mean we need to declare two classes when creating State Blocks.</p>
<p>For this example, we will begin by describing the content of the
<code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> objects, as this is where we create the variables and
constraints that describe how to calculate the thermophysical properties
of the material. After that, we will discuss how to create the class
that contains methods to be applied to the <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code> as a
whole.</p>
<section id="step-5-declare-state-variables">
<h2>Step 5: Declare State Variables<a class="headerlink" href="#step-5-declare-state-variables" title="Permalink to this headline">¶</a></h2>
<p>The first step in defining a <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> is to create the “state
variables” which will be used to define the “state” of the material at
any given point. The concept of a “state variable” in IDAES is much the
same as the concept in thermodynamics, with the exception that we
include extensive flow information in the state definition in IDAES. In
short, the “state variables” should be sufficient to fully define the
state of the material (both extensive and intensive), and should result
in a <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Block</span></code> with zero degrees of freedom if all the state
variables are fixed.</p>
<p>For this example, our state variables will be:</p>
<ul class="simple">
<li><p>total molar flow rate (<code class="docutils literal notranslate"><span class="pre">flow_mol</span></code>),</p></li>
<li><p>overall mole fractions of each component (<code class="docutils literal notranslate"><span class="pre">mole_frac_comp</span></code>),</p></li>
<li><p>temperature (<code class="docutils literal notranslate"><span class="pre">temperature</span></code>), and</p></li>
<li><p>pressure (<code class="docutils literal notranslate"><span class="pre">pressure</span></code>).</p></li>
</ul>
<p>We declare these as Pyomo <code class="docutils literal notranslate"><span class="pre">Var</span></code> components which we will attach to our
State Block Data object as shown below. Note that we need to define an
initial (default value) for each variable along with its units of
measurement (which should be consistent with those declared in the
property package metadata). Additionally, modelers should provide bounds
for the state variables (based on expected ranges of operation, known
limitations of the system or fitted region of property correlations),
and it is good practice to provide a documentation string for each.</p>
<p>When declaring variables (or <code class="docutils literal notranslate"><span class="pre">Expressions</span></code>) for physical properties,
it is important to follow the <a class="reference external" href="https://idaes-pse.readthedocs.io/en/stable/user_guide/conventions.html">IDAES naming
conventions</a>.
The standard naming conventions allow unit model developers to know what
name will be used for a given property in any property package, meaning
that any unit model can work with any property package that uses the
naming conventions.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_state_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flow_mol</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
            <span class="n">initialize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
            <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Molar flow rate&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mole_frac_comp</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">,</span>
                              <span class="n">initialize</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                              <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                              <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">,</span>
                              <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Component mole fractions&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="mi">101325</span><span class="p">,</span>
                        <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">101325</span><span class="p">,</span> <span class="mi">400000</span><span class="p">),</span>
                        <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">Pa</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;State pressure&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="mf">298.15</span><span class="p">,</span>
                           <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">298.15</span><span class="p">,</span> <span class="mi">1500</span><span class="p">),</span>
                           <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">,</span>
                           <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;State temperature&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>However, simply adding the state variables to our model is not
sufficient, as the framework has no way of distinguishing these
variables from any other variables in the property package. In order to
provide a way for the framework to identify which variables should be
considered to be the state variables, we create a <code class="docutils literal notranslate"><span class="pre">dict</span></code> which
contains a pointer to all the state variables, along with their names
(note that the name (key) should match the local name of the variable
object).</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">return_state_var_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;flow_mol&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_mol</span><span class="p">,</span>
            <span class="s2">&quot;mole_frac_comp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">,</span>
            <span class="s2">&quot;temperature&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span>
            <span class="s2">&quot;pressure&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step-6-write-constraints-and-or-expressions-for-properties-of-interest">
<h2>Step 6: Write Constraints and/or Expressions for Properties of Interest<a class="headerlink" href="#step-6-write-constraints-and-or-expressions-for-properties-of-interest" title="Permalink to this headline">¶</a></h2>
<p>Next, we need to write the equations which we will use to calculate the
properties of interest as functions of the state variables. Within
Pyomo, there are three ways in which this can be done:</p>
<ol class="arabic simple">
<li><p>by using a <code class="docutils literal notranslate"><span class="pre">Var</span></code> and a <code class="docutils literal notranslate"><span class="pre">Constraint</span></code>,</p></li>
<li><p>by using an <code class="docutils literal notranslate"><span class="pre">Expression</span></code>, or,</p></li>
<li><p>by using a <code class="docutils literal notranslate"><span class="pre">Reference</span></code>.</p></li>
</ol>
<p>The different between the first two options is that an <code class="docutils literal notranslate"><span class="pre">Expression</span></code>
does not appear in the problem passed to the solver – the <code class="docutils literal notranslate"><span class="pre">Expression</span></code>
can be evaluated by the user and included in constraints in the same way
as a variable, but when the problem is passed to the solver the
<code class="docutils literal notranslate"><span class="pre">Expression</span></code> object is substituted for the expression it represents
wherever it appears in the model. This means that there are fewer
variables and constraints in the problem the solver sees, but that the
constraints that do appear are more complex. There is no simple answer
to which approach is best, and different applications may see better
results with one form or the other. The third option, using a
<code class="docutils literal notranslate"><span class="pre">Reference</span></code> is for cases where a property already exists elsewhere in
the model, and we just want to create a local copy of the same object.
In terms of properties, this most often occurs with fixed quantities
which are declared in the Physical Parameter Block such as molecular
weights. For the purposes of this example, we will demonstrate all of
these approaches.</p>
<p>You may recall from the initial problem statement that we have three
properties of interest in this example:</p>
<ul class="simple">
<li><p>component molecular weights,</p></li>
<li><p>mixture density, and</p></li>
<li><p>mixture specific enthalpy.</p></li>
</ul>
<p>Let us start with the component molecular weights. These are of course
global parameters for each component which are not going to change, and
thus we declared these in the Physical Parameter Block. However, it is
possible that a unit model may need these values in some correlation,
and it is likely that the modeler would ask the State Block for these
values. Thus, to make sure these properties are available in the State
Block if needed, we will create a Pyomo <code class="docutils literal notranslate"><span class="pre">Reference</span></code> to the parameters
in the Physical Parameter Block using the following code:
<code class="docutils literal notranslate"><span class="pre">self.mw_comp</span> <span class="pre">=</span> <span class="pre">Reference(self.params.mw_comp)</span></code>.</p>
<p>Next, we will create a <code class="docutils literal notranslate"><span class="pre">Var</span></code> for the mixture density and a
<code class="docutils literal notranslate"><span class="pre">Constraint</span></code> to calculate it from the state variable. For this
example, we are using the ideal gas equation, so
<span class="math notranslate nohighlight">\(P = \rho \times R \times T\)</span>. First, we need to declare a variable
for the density of the mixture, which is named <code class="docutils literal notranslate"><span class="pre">dens_mol</span></code> according to
the naming standards. We then need to create the constraint with the
ideal gas equation, which requires temperature and pressure (which we
have already declared on the State Block), and the gas constant. The
IDAES modeling framework contains a library of common constants, which
we imported earlier using
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">idaes.core.util.constants</span> <span class="pre">import</span> <span class="pre">Constants</span> <span class="pre">as</span> <span class="pre">const</span></code> and we can
get the gas constant from there using <code class="docutils literal notranslate"><span class="pre">const.gas_constant</span></code>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_molecular_weight_and_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mw_comp</span> <span class="o">=</span> <span class="n">Reference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">mw_comp</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">dens_mol</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">units</span><span class="o">=</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Mixture density&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">ideal_gas_eq</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span>
        <span class="n">expr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pressure</span> <span class="o">==</span>
        <span class="n">const</span><span class="o">.</span><span class="n">gas_constant</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dens_mol</span><span class="p">)</span>
</pre></div>
</div>
<p>The last property of interest we need to declare is the mixture specific
enthalpy. For an ideal gas, the mixture specific enthalpy can be
calculated from the component specific enthalpies using the following
equation:</p>
<p><a href="#id3"><span class="problematic" id="id4">:raw-latex:`\begin{equation*}
h_{mix}= \sum{x_j \times h_j}
\end{equation*}`</span></a></p>
<p>where <span class="math notranslate nohighlight">\(x_j\)</span> is the mole fraction of component <span class="math notranslate nohighlight">\(j\)</span>. Recall
that for this example we are using the following correlation for the
component specific enthalpies.</p>
<p><a href="#id5"><span class="problematic" id="id6">:raw-latex:`\begin{equation*}
h_j – h_{j, ref}= A_j \times (T-T_{ref}) + \frac{B_j}{2}\times (T^2-T_{ref}^2) + \frac{C_j}{3}\times (T^3-T_{ref}^3) + \frac{D_j}{4}\times (T^4-T_{ref}^4)
\end{equation*}`</span></a></p>
<p>For the specific enthalpy, we will create a Pyomo <code class="docutils literal notranslate"><span class="pre">Expression</span></code> rather
than a <code class="docutils literal notranslate"><span class="pre">Var</span></code> and <code class="docutils literal notranslate"><span class="pre">Constraint</span></code>. In practice, this is much like
creating a <code class="docutils literal notranslate"><span class="pre">Constraint</span></code>. However, rather than returning an equality
between two expressions, an <code class="docutils literal notranslate"><span class="pre">Expression</span></code> requires a single numerical
expression that can be used to compute the quantity of interest.</p>
<p>When writing this <code class="docutils literal notranslate"><span class="pre">Expression</span></code>, we need a few things from different
parts of the property package. First, we need to get the parameters
(<span class="math notranslate nohighlight">\(A_j\)</span>, <span class="math notranslate nohighlight">\(B_j\)</span>, <span class="math notranslate nohighlight">\(C_j\)</span>, <span class="math notranslate nohighlight">\(D_j\)</span>, <span class="math notranslate nohighlight">\(h_{j, ref}\)</span>
and <span class="math notranslate nohighlight">\(T_{ref}\)</span>) from the Physical Parameter Block. The State Block
base class contains a pointer to the associated Physical Parameter Block
named <code class="docutils literal notranslate"><span class="pre">self.params</span></code> which we can use to directly access these, and we
will create a shorthand alias to keep the length of our equation down.
We will also create a specific shorthand for the reference temperature,
as the full name can get rather long. Then, we need to write out the
full expression for the specific molar enthalpy, which also requires the
temperature and mole fraction state variables from the State Block.
Creating the <code class="docutils literal notranslate"><span class="pre">Expression</span></code> for the specific molar enthalpy is shown in
the code below.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_enth_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">enth_rule</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span>
        <span class="n">Tr</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">temperature_ref</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="mi">4</span><span class="o">-</span><span class="n">Tr</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="mi">3</span><span class="o">-</span><span class="n">Tr</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">Tr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">params</span><span class="o">.</span><span class="n">cp_mol_ig_comp_coeff_A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">-</span><span class="n">Tr</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">params</span><span class="o">.</span><span class="n">enth_mol_form_vap_comp_ref</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">enth_mol</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">rule</span><span class="o">=</span><span class="n">enth_rule</span><span class="p">)</span>
</pre></div>
</div>
<p>We have now created the necessary calculations for the properties of
interest in our property package, but we are not quite finished with
equations yet. We also need to provide an equation that limits the sum
of the component mole fractions to be equal to 1,
i.e. <span class="math notranslate nohighlight">\(1 = \sum{x_j}\)</span>. However, there is a catch here; the mole
fractions are part of the state variables, and thus they end up in the
streams connecting unit operations together. Thus, at the inlet to a
unit model, all of the mole fractions will be defined by the outlet of
the previous unit operation. That is, if we add a constraint for the sum
of mole fractions at the inlet of a unit operation, we will find we have
over-specified the problem and it cannot be solved.</p>
<p>To deal with this issue, the each State Block includes a configuration
argument (inherited from the base class) named <code class="docutils literal notranslate"><span class="pre">defined_state</span></code>. This
argument is set by the parent unit model when it creates each instance
of s State Block, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> wherever the material state is
fully defined (most commonly at the inlets). Thus, in our State Block we
can add a check for the <code class="docutils literal notranslate"><span class="pre">defined_state</span></code> configuration argument
(<code class="docutils literal notranslate"><span class="pre">self.config.defined_state</span></code>), and only write the sum of mole
fractions constraint if this is <code class="docutils literal notranslate"><span class="pre">False</span></code> as shown below. Note also that
we have added a scaling factor of 1,000 to the constraint to try to
improve the robustness of the model. The IDAES modeling framework
includes tools for automatically scaling variables and constraints, but
these are beyond the scope of this example.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_mole_fraction_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">defined_state</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mole_fraction_constraint</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span>
            <span class="n">expr</span><span class="o">=</span><span class="mf">1e3</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_list</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="step-7-define-an-initialization-routine">
<h2>Step 7: Define an Initialization Routine<a class="headerlink" href="#step-7-define-an-initialization-routine" title="Permalink to this headline">¶</a></h2>
<p>Now that we have written the variables and constraints required to
describe the properties of interest for our material, it would be
tempting to think that most of the work is now done. Unfortunately, this
is only half the work required as we still need to develop an
initialization routine for our property package. Whilst we have provided
default values for all the variables in our model as we created them,
these are most likely not the actual conditions that the end user will
wish to simulate. Given the often highly non-linear nature of physical
property calculations, it is more often than not impossible to solve a
State Block without providing a set of good initial values for all the
variables we have declared; this is the purpose of the initialization
routine.</p>
<p>The art of writing good, robust initialization routines is enough for a
series of tutorials in itself, so this example will focus on the
mechanics of how to write an initialization routine. Fortunately, our
current example is simple enough that we do not need to do much to get a
set of good initial guesses. Generally speaking, an initialization
routine consists of three stages (these stages are general and apply to
any model)):</p>
<ol class="arabic simple">
<li><p>Fix the state of the model such that there are no degrees of freedom.
For State Blocks, it should only be necessary to fix the state
variables to a set of initial guesses provided by the user or unit
model, as well as deactivating any constraints like the sum of mole
fractions.</p></li>
<li><p>Iteratively build up a solution for the full model. This often
involves multiple steps and can involve deactivating constraints and
fixing some variables to reduce complexity, as well as analytically
calculating values for variables based on the known state (and any
previously calculated variables). Solvers can be called as part of
any step to efficiently initialize large numbers of variables
simultaneously.</p></li>
<li><p>Return the state of the model to where it originally started (with
the exception of variable values). Any variable that was fixed or
constraint that was deactivated during initialization should be
unfixed or reactivated, so that the degrees of freedom are restored
to what they were before the initialization began.</p></li>
</ol>
<section id="state-blocks-and-indexing">
<h3>State Blocks and Indexing<a class="headerlink" href="#state-blocks-and-indexing" title="Permalink to this headline">¶</a></h3>
<p>You should be aware by now that State Blocks are always indexed, at
least by time and possibly by space as well. The methods we wrote above
for creating variables and constraints all looked at a single element
within the <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code>, i.e. a single <code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code>. This
is because we need to write these variables and constraints for each
state within the model. However, when it comes to initialization, we
generally want to perform the same operations on each <code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code>
- i.e. the initialization for each element is the same. Thus, rather
than writing an initialization method for a single element, and then
calling it repeatedly as we iterate over all the elements, it would be
convenient to write a single method that could initialize all the
<code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> within an <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code> simultaneously. This
would greatly reduce the number of solver calls we would need to make,
thus reducing the overhead associated with those solver calls.</p>
<p>Fortunately, the IDAES modeling framework supports this and the
following code will show how to do this. The important thing to note is
that the initialization methods are written to act on an arbitrary
<code class="docutils literal notranslate"><span class="pre">IndexedBlock</span></code> which we refer to as <code class="docutils literal notranslate"><span class="pre">blk</span></code> (as opposed to the
<code class="docutils literal notranslate"><span class="pre">self</span></code> we used previously). This <code class="docutils literal notranslate"><span class="pre">blk</span></code> represents the
<code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code> and contains a set of elements which we can
iterate over as needed (the <code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> objects). By having
access to the <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code> we can perform actions both on
individual <code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> and on the overall <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code>
as needed.</p>
</section>
<section id="writing-the-initialization-routine">
<h3>Writing the Initialization Routine<a class="headerlink" href="#writing-the-initialization-routine" title="Permalink to this headline">¶</a></h3>
<p>For initializing State Blocks, the first step is to get our model to a
state where it has no degrees of freedom. As mentioned earlier, fixing
all of the state variables should be sufficient to fully define the
state of the material – i.e. no degrees of freedom. Additionally, we
want to initialize our State Block at a set of conditions that are good
initial guesses for the final state of the model once it is finally
solved. Of course, the State Block has no way of knowing what these
initial values should be, so we depend on the unit model (or the
end-user) to provide us with a set of initial values to use – this is
done through a <code class="docutils literal notranslate"><span class="pre">dict</span></code> which we generally call <code class="docutils literal notranslate"><span class="pre">state_args</span></code> where the
keys are the names of the state variables and the values are the initial
guesses.</p>
<p>Before we start fixing the state variables, there is the possibility
that all the state variables have already been fixed (e.g. by a the unit
model during its own initialization routine). To allow us to save some
time, we include a <code class="docutils literal notranslate"><span class="pre">state_vars_fixed</span></code> argument in our State Block
initialization methods that lets the unit model tell us if the state
variables are already fixed – if this is <code class="docutils literal notranslate"><span class="pre">True</span></code> then we know we can
skip the step of checking the state variables ourselves. If
<code class="docutils literal notranslate"><span class="pre">state_vars_fixed</span> <span class="pre">is</span> <span class="pre">False</span></code> however, then we need to go and fix all
the state variables as part of our initialization routine. To save us
the effort of having to code all of this ourselves, the IDAES toolkit
contains a utility method named <code class="docutils literal notranslate"><span class="pre">fix_state_vars</span></code> (which we imported
earlier), which takes the <code class="docutils literal notranslate"><span class="pre">state_args</span></code> <code class="docutils literal notranslate"><span class="pre">dict</span></code> and then iterates
through all the state variables as defined by the State Block (using the
<code class="docutils literal notranslate"><span class="pre">dict</span></code> we declared earlier in the <code class="docutils literal notranslate"><span class="pre">return_state_var_dict</span></code>
sub-method). This method iterates through all the defined state
variables and does the following:</p>
<ol class="arabic simple">
<li><p>If the variable is already fixed, it records this and does nothing.
If a variable is already fixed, we assume it was fixed for a reason
and that we should not change its value.</p></li>
<li><p>If the variable is not fixed, this is recorded and the method then
checks the <code class="docutils literal notranslate"><span class="pre">state_args</span></code> dict for an initial guess for the variable.
If a value is found, the variable is fixed to this value; otherwise,
the variable is fixed to its current value.</p></li>
</ol>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">fix_state_vars</span></code> method returns a <code class="docutils literal notranslate"><span class="pre">dict</span></code> that records
which variables were fixed by the method, so that we can later reverse
these changes. In the example below, we refer to this <code class="docutils literal notranslate"><span class="pre">dict</span></code> as
<code class="docutils literal notranslate"><span class="pre">flags</span></code>.</p>
<p>At this point, all the state variables should now be fixed, but once
again we have a small catch – if we fix all the state variables then we
have a situation similar to the inlet of a unit where we cannot write a
constraint on the sum of mole fractions and still solve the model. Thus
we need to deactivate this constraint if it exists (remembering that
this constraint will not exist in all State Blocks). We know that this
constraint will only exist if <code class="docutils literal notranslate"><span class="pre">defined_state</span> <span class="pre">is</span> <span class="pre">False</span></code>, so we start by
writing an <code class="docutils literal notranslate"><span class="pre">IF</span></code> statement to check for this and then use the Pyomo
<code class="docutils literal notranslate"><span class="pre">deactivate()</span></code> method to deactivate the constraint (remembering that
we will need to reactivate it later).</p>
<p>Before we move on however, it is probably a good idea to check the
degrees of freedom to be sure that they are zero (as expected). There
are a number of ways things could go wrong (e.g., the unit model said
the state variables were fixed when not all of them were, or we missed a
constraint we need to deactivate), so a quick check now might save
someone a lot of pain in the future. We can use the IDAES
<code class="docutils literal notranslate"><span class="pre">degrees_of_freedom</span></code> method to check the degrees of freedom of our
State Block, and if this is not zero raise an <code class="docutils literal notranslate"><span class="pre">Exception</span></code> to let the
user know something went wrong.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prepare_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">state_args</span><span class="p">,</span> <span class="n">state_vars_fixed</span><span class="p">):</span>
    <span class="c1"># Fix state variables if not already fixed</span>
    <span class="k">if</span> <span class="n">state_vars_fixed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="n">fix_state_vars</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">state_args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Deactivate sum of mole fractions constraint</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">blk</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">blk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">defined_state</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">blk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mole_fraction_constraint</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>

    <span class="c1"># Check that degrees of freedom are zero after fixing state vars</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">blk</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">degrees_of_freedom</span><span class="p">(</span><span class="n">blk</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;State vars fixed but degrees of freedom &quot;</span>
                            <span class="s2">&quot;for state block is not zero during &quot;</span>
                            <span class="s2">&quot;initialization.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">flags</span>
</pre></div>
</div>
<p>Now that we know we have no degrees of freedom in our State Blocks, we
can begin the process of building up initial values for all the other
variables in our model. The current example is simple enough that it can
be solved directly once the state variables are fixed, but more rigorous
models (such as those with phase equilibria) will likely require
multiple steps to initialize. The code below shows how we call a solver
to solve the entire <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code> in one go.</p>
<p>Before we call the solver, we first need to make sure there is actually
something to solve; depending on how the State Block is written
(e.g. build-on-demand properties and use of <code class="docutils literal notranslate"><span class="pre">Expressions</span></code>), it is
sometimes possible that there are actually no <code class="docutils literal notranslate"><span class="pre">Constraints</span></code> to be
solved in the model. If we try to send a problem like that to a solver,
we will likely get back an error message which is not what we want to
see. Whilst we know that our State Block will always contain at least
one constraint (for mixture density), we will add a check here anyway to
show how it is done. First ,we create a counter to keep track of the
number of unfixed variables in the system, <code class="docutils literal notranslate"><span class="pre">free_vars</span></code>. Then we
iterate over all the elements of the <code class="docutils literal notranslate"><span class="pre">blk</span></code> (the <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code>)
and check how many free variables are in each. We use the
<code class="docutils literal notranslate"><span class="pre">number_unfixed_variables()</span></code> method from the
<code class="docutils literal notranslate"><span class="pre">idaes.core.util.model_statistics</span></code> module to do this, and add the
result <code class="docutils literal notranslate"><span class="pre">free_vars</span></code> for each element. If the final value of
<code class="docutils literal notranslate"><span class="pre">free_vars</span></code> is not zero, then we know there is something to solve for
and we can proceed to call a solver; otherwise we know that we can skip
this step.</p>
<p>In order to solve the entire <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code>, we need to do things
slightly differently than normal. The standard Pyomo <code class="docutils literal notranslate"><span class="pre">SolverFactory</span></code>
cannot be applied to indexed blocks, so instead we use the IDAES
<code class="docutils literal notranslate"><span class="pre">solve_indexed_block</span></code> method (imported from
<code class="docutils literal notranslate"><span class="pre">idaes.core.initialization</span></code>) which puts a wrapper around the indexed
block so that we can use Pyomo’s solver interface. In order to use this
method, we need to provide a Pyomo <code class="docutils literal notranslate"><span class="pre">SolverFactory</span></code> object (called
<code class="docutils literal notranslate"><span class="pre">solver</span></code> here, which also includes any attached solver options) along
with the <code class="docutils literal notranslate"><span class="pre">blk</span></code> we wish to solve and where to send the solver results
(the <code class="docutils literal notranslate"><span class="pre">tee</span></code> argument). Additionally, we want the user to have the
ability to control the output from the solver through the IDAES logger
interface, which we do by wrapping the solver call with the following
line of code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">idaeslog</span><span class="o">.</span><span class="n">solver_log</span><span class="p">(</span><span class="n">solve_log</span><span class="p">,</span> <span class="n">idaeslog</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span> <span class="k">as</span> <span class="n">slc</span><span class="p">:</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">idaeslog</span></code> is an instance of the IDAES logger. Note that we send
the solver output to this logger by setting <code class="docutils literal notranslate"><span class="pre">tee=slc</span></code>. In this way,
all the output from the solver is passed into the logger allowing users
to easily control the output level without needing to send additional
arguments to the initialization methods.</p>
<p>If all goes well, the solver will successfully initialize our model and
we can move on. However, sometimes the solver will fail
catastrophically, in which case we need to make sure that our
initialization routine can attempt to recover. In order to do this, we
wrap the solver call within a Python <code class="docutils literal notranslate"><span class="pre">try/except</span></code> statement. This way,
if the solver fails badly and returns an <code class="docutils literal notranslate"><span class="pre">Exception</span></code>, we can capture
this and decide how to process – otherwise the execution of our model
would terminate with the exception from the solver. In the case we
encounter an <code class="docutils literal notranslate"><span class="pre">Exception</span></code> here, we will record <code class="docutils literal notranslate"><span class="pre">results=None</span></code> and try
to continue with initializing our model in the hope that we can recover.</p>
<p>Finally, it is useful to provide the user with some feedback on how the
initialization is proceeding. In the last lines below, we send a message
to the IDAES logger with a message saying that the initialization step
has been completed and append the final solver status.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">initialize_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">init_log</span><span class="p">,</span> <span class="n">solve_log</span><span class="p">):</span>
    <span class="c1"># Check that there is something to solve for</span>
    <span class="n">free_vars</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">blk</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">free_vars</span> <span class="o">+=</span> <span class="n">number_unfixed_variables</span><span class="p">(</span><span class="n">blk</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">free_vars</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># If there are free variables, call the solver to initialize</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">idaeslog</span><span class="o">.</span><span class="n">solver_log</span><span class="p">(</span><span class="n">solve_log</span><span class="p">,</span> <span class="n">idaeslog</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span> <span class="k">as</span> <span class="n">slc</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">solve_indexed_blocks</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="p">[</span><span class="n">blk</span><span class="p">],</span> <span class="n">tee</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#slc.tee)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">init_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Properties Initialized </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">idaeslog</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">res</span><span class="p">)))</span>
</pre></div>
</div>
<p>One we have finished initializing all the variables in our State Block,
the last step is to return the state of all variables and constraints to
what they were before we started; i.e. unfixing any variables that were
fixed as part of the initialization, and reactivating any constraints
that were deactivated. However, at this point we need to be aware of the
fact that the State Block initialization is generally occurring as part
of the initialization of a unit model, and that there are often cases
where the unit model might want us to delay restoring the state of the
State Block. The most common occurrence of this is for State Blocks
which represent inlets to unit models; State Block initialization is
generally the first step in initializing a unit model, after which the
unit model generally needs to do some additional steps to fully
initialize itself. In order for the unit model to do this, the state
variables for the inlet generally need to be fixed. Thus, rather than
having to fix the state variables itself, the unit model would often
like the inlet state to remain fixed until the unit model finishes
initializing itself.</p>
<p>In order to achieve this, all State Block initialization methods get
passed a <code class="docutils literal notranslate"><span class="pre">hold_state</span></code> argument by the unit model, and if this is
<code class="docutils literal notranslate"><span class="pre">True</span></code> it indicates that the unit model wants the state to remain
fixed until it is ready. Within the State Block then, we need to
separate the code for restoring the model state into a separate
<code class="docutils literal notranslate"><span class="pre">release_state</span></code> method which takes the <code class="docutils literal notranslate"><span class="pre">flags</span></code> dict from earlier as
an argument. Then, in the State Block initialization routine, we need to
check the <code class="docutils literal notranslate"><span class="pre">hold_state</span></code> argument and do the following:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">hold_state</span> <span class="pre">is</span> <span class="pre">True</span></code>, return the <code class="docutils literal notranslate"><span class="pre">flags</span></code> dict to the unit
model so that it can call the <code class="docutils literal notranslate"><span class="pre">restore_state</span></code> method later when it
is done, or</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">hold_state</span> <span class="pre">is</span> <span class="pre">False</span></code>, call the <code class="docutils literal notranslate"><span class="pre">restore_state</span></code> method
immediately, passing the <code class="docutils literal notranslate"><span class="pre">flag</span></code> dict as an argument.</p></li>
</ul>
<p>This is shown in the code below.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">restore_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">hold_state</span><span class="p">):</span>
    <span class="c1"># Return state to initial conditions</span>
    <span class="k">if</span> <span class="n">hold_state</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flags</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blk</span><span class="o">.</span><span class="n">release_state</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we need to write the <code class="docutils literal notranslate"><span class="pre">restore_state</span></code> method for our State Block,
which needs to perform two tasks. First, it needs to reactivate the sum
of mole fractions constraint if it exists, and then it needs to unfix
the state variables base on the information stored in the <code class="docutils literal notranslate"><span class="pre">flags</span></code>
dict. Looking back to when we fixed the state variables initially, we
will note that it is possible for <code class="docutils literal notranslate"><span class="pre">flags</span> <span class="pre">=</span> <span class="pre">None</span></code> (indicating that the
<code class="docutils literal notranslate"><span class="pre">state_Vars_fixed</span></code> argument was <code class="docutils literal notranslate"><span class="pre">True</span></code>). In this case, we must
assume the unit model knows what it is doing and we can skip unfixing
the state variables here. Otherwise, we can call the
<code class="docutils literal notranslate"><span class="pre">revert_state_vars</span></code> method (imported from
<code class="docutils literal notranslate"><span class="pre">idaes.core.util.initialization</span></code>) and pass <code class="docutils literal notranslate"><span class="pre">blk</span></code> and <code class="docutils literal notranslate"><span class="pre">flags</span></code> as
arguments, which will automatically restore all the state variables to
their original state. Finally, it is helpful to log a message saying
that the state has been restored to assist with debugging in the future.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">unfix_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">outlvl</span><span class="p">):</span>
    <span class="n">init_log</span> <span class="o">=</span> <span class="n">idaeslog</span><span class="o">.</span><span class="n">getInitLogger</span><span class="p">(</span><span class="n">blk</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">outlvl</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;properties&quot;</span><span class="p">)</span>

    <span class="c1"># Reactivate sum of mole fractions constraint</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">blk</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">blk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">defined_state</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">blk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mole_fraction_constraint</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">flags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Unfix state variables</span>
        <span class="n">revert_state_vars</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>

    <span class="n">init_log</span><span class="o">.</span><span class="n">info_high</span><span class="p">(</span><span class="s2">&quot;State Released.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="creating-the-stateblock-and-stateblockdata-classes">
<h2>Creating the StateBlock and StateBlockData classes<a class="headerlink" href="#creating-the-stateblock-and-stateblockdata-classes" title="Permalink to this headline">¶</a></h2>
<p>We have now defined almost all the of methods we will need to construct
the actual State Block classes, and those that remain will be built
directly as part of the classes. To begin, we need to declare the class
which will be used to construct the <code class="docutils literal notranslate"><span class="pre">IndexedStateBlock</span></code>, and that
contains the methods associated with initializing the State Block.
Whilst this might seem a little counter-intuitive (defining
initialization before we define the actual model), it is necessary to do
it this way as we need to have defined this class before we can define
the <code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> class (for reasons that you will see later).</p>
<section id="the-stateblock-class">
<h3>The StateBlock class<a class="headerlink" href="#the-stateblock-class" title="Permalink to this headline">¶</a></h3>
<p>To begin, we declare a new class which inherits from the IDAES
<code class="docutils literal notranslate"><span class="pre">StateBlock</span></code> base class, which we will call <code class="docutils literal notranslate"><span class="pre">_HDAStateBlock</span></code> here.
Note that we need to be careful with naming here; later we will be
automatically generating a class names <code class="docutils literal notranslate"><span class="pre">HDAStateBlock</span></code> which will be
the actual state block that we use for our model (and incidentally the
one we created a pointer to back in the Physical Parameter Block class).
Thus, we add an underscore to the beginning of this class name to
distinguish it from the class that will be generated later, and to
indicate that this is for internal use only by the property package.</p>
<p>Next, the <code class="docutils literal notranslate"><span class="pre">_HDAStateBlock</span></code> class needs to have two methods added to
it; <code class="docutils literal notranslate"><span class="pre">initialize</span></code> and <code class="docutils literal notranslate"><span class="pre">release_state</span></code> which are used to run the
initialization routine for the State Block. Each of these have a set of
arguments which must be part of the method definition (you can add more
if you have a need for them, but the pre-defined set are a minimum).</p>
<section id="the-initialize-method">
<h4>The <code class="docutils literal notranslate"><span class="pre">initialize</span></code> method<a class="headerlink" href="#the-initialize-method" title="Permalink to this headline">¶</a></h4>
<p>As the name suggests, the <code class="docutils literal notranslate"><span class="pre">initialize</span></code> method is used to run the
initialization routine for the State Block, and this is where we will
use the <code class="docutils literal notranslate"><span class="pre">prepare_state</span></code>, <code class="docutils literal notranslate"><span class="pre">initialize_state</span></code> and <code class="docutils literal notranslate"><span class="pre">restore_state</span></code>
methods we wrote previously. The <code class="docutils literal notranslate"><span class="pre">initialize</span></code> method requires the
following arguments to be declared:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">blk</span></code>: this will be a pointer to an instance of the State Block to
be initialized.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state_args</span></code>: this is used to pass the ‘dict’ of initial guesses to
the initialization routine. This should default to <code class="docutils literal notranslate"><span class="pre">None</span></code> if not
provided. The <code class="docutils literal notranslate"><span class="pre">fix_state_vars</span></code> method will interpret a value of
<code class="docutils literal notranslate"><span class="pre">None</span></code> as no guesses provided as use the current values instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solver</span></code>: this argument is used to allow tell the State Block to
use a specific solver during initialization, and should be a string
recognized by the Pyomo <code class="docutils literal notranslate"><span class="pre">SolverFactory</span></code>. We generally set this to
<code class="docutils literal notranslate"><span class="pre">None</span></code> in order to signify that IDAES Should use the default solver
(which is IPOPT).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optarg</span></code>: this argument is used to set any solver options the user
desires. Again this is generally set to <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate that the
default solver settings should be used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state_vars_fixed</span></code>: argument to allow the unit model to inform the
State Block that the state variables are already fixed. This should
default to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hold_state</span></code>: argument used to allow the unit model to inform the
State Block that the state variables should not be unfixed at the end
of the initialization routine and that it should return the <code class="docutils literal notranslate"><span class="pre">flags</span></code>
<code class="docutils literal notranslate"><span class="pre">dict</span></code> so that the unit model can do this later.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">outlvl</span></code>: this argument is used to inform the State Block of the
current logger output settings, and should default to
<code class="docutils literal notranslate"><span class="pre">idaeslog.NOTSET</span></code>.</p></li>
</ul>
<p>The code below shows the <code class="docutils literal notranslate"><span class="pre">initialize</span></code> method for our current example.
The method begins by setting up the <code class="docutils literal notranslate"><span class="pre">logger</span></code> objects that will be used
to record any messages generated by the initialization routine. Next,
the IDAES <code class="docutils literal notranslate"><span class="pre">get_solver</span></code> is used to create the <code class="docutils literal notranslate"><span class="pre">solver_obj</span></code> object
that will be used during initialization and sets the solver options.
Then, the <code class="docutils literal notranslate"><span class="pre">prepare_state</span></code>, <code class="docutils literal notranslate"><span class="pre">initialize_state</span></code> and <code class="docutils literal notranslate"><span class="pre">restore_state</span></code>
methods are called in order to initialize the State Block, providing any
arguments as required. Finally, we log a message to inform the user that
the initialization routine has successfully completed.</p>
</section>
<section id="the-release-state-method">
<h4>The <code class="docutils literal notranslate"><span class="pre">release_state</span></code> method<a class="headerlink" href="#the-release-state-method" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">release_state</span></code> method is used to handle the unfixing of the state
variables and reactivation of any constraints that may have remained
deactivated at this point. The <code class="docutils literal notranslate"><span class="pre">release_State</span></code> method requires the
following arguments:</p>
<ul class="simple">
<li><p>blk: a pointer to an instance of the State Block for which to unfix
the state variables.</p></li>
<li><p>flags: a <code class="docutils literal notranslate"><span class="pre">dict</span></code> of which state variables were fixed in the first
stage of initialization, as returned from the <code class="docutils literal notranslate"><span class="pre">fix_state_vars</span></code>
method. This argument should not have a default, as it needs to be
provided.</p></li>
<li><p>outlvl: as before, this argument is used to inform the State Block of
the current logger output settings, and should default to
<code class="docutils literal notranslate"><span class="pre">idaeslog.NOTSET</span></code>.</p></li>
</ul>
<p>In the <code class="docutils literal notranslate"><span class="pre">release_state</span></code> method below we directly call the
<code class="docutils literal notranslate"><span class="pre">unfix_state</span></code> method we wrote above with the same arguments as the
<code class="docutils literal notranslate"><span class="pre">release_State</span></code> method.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_HDAStateBlock</span><span class="p">(</span><span class="n">StateBlock</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">state_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">state_vars_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">hold_state</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outlvl</span><span class="o">=</span><span class="n">idaeslog</span><span class="o">.</span><span class="n">NOTSET</span><span class="p">,</span>
                   <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optarg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">init_log</span> <span class="o">=</span> <span class="n">idaeslog</span><span class="o">.</span><span class="n">getInitLogger</span><span class="p">(</span><span class="n">blk</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">outlvl</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;properties&quot;</span><span class="p">)</span>
        <span class="n">solve_log</span> <span class="o">=</span> <span class="n">idaeslog</span><span class="o">.</span><span class="n">getSolveLogger</span><span class="p">(</span><span class="n">blk</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">outlvl</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;properties&quot;</span><span class="p">)</span>

        <span class="c1"># Create solver</span>
        <span class="n">solver_obj</span> <span class="o">=</span> <span class="n">get_solver</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">optarg</span><span class="p">)</span>

        <span class="n">flags</span> <span class="o">=</span> <span class="n">prepare_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">state_args</span><span class="p">,</span> <span class="n">state_vars_fixed</span><span class="p">)</span>
        <span class="n">initialize_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">solver_obj</span><span class="p">,</span> <span class="n">init_log</span><span class="p">,</span> <span class="n">solve_log</span><span class="p">)</span>
        <span class="n">restore_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">hold_state</span><span class="p">)</span>

        <span class="n">init_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initialization Complete&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">release_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">outlvl</span><span class="o">=</span><span class="n">idaeslog</span><span class="o">.</span><span class="n">NOTSET</span><span class="p">):</span>
        <span class="n">unfix_state</span><span class="p">(</span><span class="n">blk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">outlvl</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="the-stateblockdata-class">
<h3>The StateBlockData class<a class="headerlink" href="#the-stateblockdata-class" title="Permalink to this headline">¶</a></h3>
<p>Finally, we can build the <code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> class, which we will call
<code class="docutils literal notranslate"><span class="pre">HDAStateBlockData</span></code>. First, we use the <code class="docutils literal notranslate"><span class="pre">declare_process_block_class</span></code>
decorator but this time we provide two arguments. The first argument is
the name of the class that will be automatically constructed for us
(<code class="docutils literal notranslate"><span class="pre">HDAStateBlock</span></code>) whilst the second argument is a reference to the
class we wish to use as the base when building the
<code class="docutils literal notranslate"><span class="pre">IndexedHDAStateBlock</span></code> class – i.e. the <code class="docutils literal notranslate"><span class="pre">_HDAStateBlock</span></code> class we
just declared. Then, we declare our new <code class="docutils literal notranslate"><span class="pre">HDAStateBlockData</span></code> class and
inherit from the IDAES <code class="docutils literal notranslate"><span class="pre">StateBlockData</span></code> base class.</p>
<p>As usual, the first thing we need to define in our new class is a
<code class="docutils literal notranslate"><span class="pre">build</span></code> method, where we will provide the instructions for
constructing our property model, and once again the first thing we
should do is call <code class="docutils literal notranslate"><span class="pre">super().build()</span></code> to construct all the underlying
components defined by the parent class. After this, we can call the
methods we wrote earlier to construct the state variables and the add
the calculations for the properties of interest.</p>
<p>However, if you recall from when we defined the properties metadata at
the beginning of the example, we decided that the specific molar
enthalpy of the mixture would be a “build-on-demand” property (i.e., we
provided a specific method in the properties metadata rather than
<code class="docutils literal notranslate"><span class="pre">None</span></code>). Thus, we do not want to call the method to construct the
specific molar enthalpy as part of the <code class="docutils literal notranslate"><span class="pre">build</span></code> method, meaning that we
only call the <code class="docutils literal notranslate"><span class="pre">add_state_variables</span></code>, <code class="docutils literal notranslate"><span class="pre">add_mole_fraction_constraint</span></code>
and <code class="docutils literal notranslate"><span class="pre">add_molecular_weight_and_density</span></code> as in the <code class="docutils literal notranslate"><span class="pre">build</span></code> method.</p>
<p>To add the specific molar enthalpy calculation as a “build-on-demand”
property, we instead declare a separate method with the name we provided
in the properties metadata. Whenever the specific molar enthalpy is
required by a unit model it will check to see if the property already
exists, and if not it will look up the properties metadata and call the
method listed there; i.e. <code class="docutils literal notranslate"><span class="pre">_enth_mol</span></code> in this case. Thus, we declare
another method on our <code class="docutils literal notranslate"><span class="pre">HDAStateBlockData</span></code> class named <code class="docutils literal notranslate"><span class="pre">enth_mol</span></code>
which takes only the class instance as an argument (<code class="docutils literal notranslate"><span class="pre">self</span></code>), and then
call the <code class="docutils literal notranslate"><span class="pre">add_enth_mol</span></code> method we created earlier to construct the
required <code class="docutils literal notranslate"><span class="pre">Expression</span></code>.</p>
<p>That is all we need to do in order to construct the variables and
constraints we need for the property calculations. However, there are a
number of other things we need to define in our State Block Data class.
In order to provide much of the flexibility present in the IDAES
modeling framework, we defer making decisions on much of the form of the
overall model for as long as possible. However, these decisions need to
be made at some point, and the State Block Data is where this finally
occurs.</p>
<p>The first thing we need to do is to define the state variables used by
the property package using the <code class="docutils literal notranslate"><span class="pre">return_state_var_dict</span></code> dict we
declared earlier. This dict is used for many important decisions, such
as determining which variables should be fixed by the <code class="docutils literal notranslate"><span class="pre">fix_state_vars</span></code>
method during initialization, and what information should be included in
the <code class="docutils literal notranslate"><span class="pre">Ports</span></code> of the unit models. To do this, we need to define a method
named <code class="docutils literal notranslate"><span class="pre">define_state_vars</span></code> in our State Block Data class, which returns
the dict of state variables.</p>
<p>Next, we need to provide methods which tell the unit model (and
associated control volumes) how the flow terms should be defined in the
material and energy balances. This is a core aspect of the flexibility
of the IDAES modeling framework, as different forms for the flow terms
may be more or less amenable to different formulations of the property
calculations (primarily the state variables). Thus, we let the property
package decide on the best form to use, which is achieved by defining
methods in the State Block Data which return the desired form of the
flow terms. Whenever a unit model or control volume requires a flow
term, it looks to these methods in the State Block in order to know what
expression should be used for the flow terms. Thus, we need to define
two methods in our property package:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">get_material_flow_terms(self,</span> <span class="pre">p,</span> <span class="pre">j)</span></code>: this method should return
the desired expression for the material flow term, indexed by phase
<code class="docutils literal notranslate"><span class="pre">p</span></code> and component <code class="docutils literal notranslate"><span class="pre">j</span></code>. Note that the <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> indexes are
required, even if the property package only contains one phase and/or
component. If you do have a case where you only have one phase or
component (such as this case, where we only have 1 phase), you can
just ignore the indices that are not required. For this example, the
material flow term we need to use is total flow rate multiplied by
component mole fractions, or <code class="docutils literal notranslate"><span class="pre">self.flow_mol*self.mole_frac_comp[j]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_enthalpy_flow_terms(self,</span> <span class="pre">p)</span></code>: this method should return the
desired enthalpy flow term, indexed only by phase <code class="docutils literal notranslate"><span class="pre">p</span></code> (enthalpy by
component does not make a lot of sense). In this case, the enthalpy
flow term we need to use is molar flow rate multiplied by specific
enthalpy, i.e. <code class="docutils literal notranslate"><span class="pre">self.flow_mol*self.enth_mol</span></code>.</p></li>
</ul>
<p>For dynamic flowsheets, it is also necessary to define methods for the
material and internal energy density of the mixture (required to
calculate holdup terms); however, we will not define these in this
example.</p>
<p>Next, the IDAES modeling framework gives the user the ability to choose
different forms for the material and energy balance equations; however,
the tractability of each form is significantly determined by the form of
the property calculations. The State Block should specify a default form
for the material and energy balances that is expected to be tractable
under most circumstance (the end-user can override this as necessary).
To do this, we also need to define two methods which set the default
balance type to use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">default_material_balance_type</span></code> should return an instance of the
IDAES <code class="docutils literal notranslate"><span class="pre">MaterialBalanceType</span></code> <code class="docutils literal notranslate"><span class="pre">Enum</span></code> (imported from
<code class="docutils literal notranslate"><span class="pre">idaes.core</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default_energy_balance_type</span></code> should return an instance of the
IDAES <code class="docutils literal notranslate"><span class="pre">EnergyBalanceType</span></code> <code class="docutils literal notranslate"><span class="pre">Enum</span></code> (imported from <code class="docutils literal notranslate"><span class="pre">idaes.core</span></code>).</p></li>
</ul>
<p>Finally, we need to specify the basis of the material flow terms (mass,
mole or other). This is used to automatically convert between different
bases as required (e.g. a user can define a custom mass transfer term on
a molar basis whilst using a mass basis for the actual material
balance). Note that automatic conversion only works for mass and molar
basis; the “other” basis is used to indicate forms which cannot be
easily converted (i.e., the modeler needs to handle this manually). To
define the material flow term basis we define a final method named
<code class="docutils literal notranslate"><span class="pre">get_material_flow_basis</span></code> which returns an instance of the IDAES
<code class="docutils literal notranslate"><span class="pre">MaterialFlowBasis</span></code> <code class="docutils literal notranslate"><span class="pre">Enum</span></code> (again imported from <code class="docutils literal notranslate"><span class="pre">idaes.core</span></code>).</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@declare_process_block_class</span><span class="p">(</span><span class="s2">&quot;HDAStateBlock&quot;</span><span class="p">,</span>
                             <span class="n">block_class</span><span class="o">=</span><span class="n">_HDAStateBlock</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">HDAStateBlockData</span><span class="p">(</span><span class="n">StateBlockData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example property package for an ideal gas containing benzene, toluene</span>
<span class="sd">    hydrogen, methane and diphenyl.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Callable method for Block construction.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HDAStateBlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="n">add_state_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">add_mole_fraction_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">add_molecular_weight_and_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_enth_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">add_enth_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">define_state_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">return_state_var_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_material_flow_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_mol</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_enthalpy_flow_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create enthalpy flow terms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_mol</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">enth_mol</span>

    <span class="k">def</span> <span class="nf">default_material_balance_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MaterialBalanceType</span><span class="o">.</span><span class="n">componentPhase</span>

    <span class="k">def</span> <span class="nf">default_energy_balance_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">EnergyBalanceType</span><span class="o">.</span><span class="n">enthalpyTotal</span>

    <span class="k">def</span> <span class="nf">get_material_flow_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MaterialFlowBasis</span><span class="o">.</span><span class="n">molar</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="demonstration">
<h1>Demonstration<a class="headerlink" href="#demonstration" title="Permalink to this headline">¶</a></h1>
<p>We have now finished writing our example property package, so let us put
it to use in a simple demonstration.</p>
<p>First, we need to import some basic components from <code class="docutils literal notranslate"><span class="pre">pyomo.environ</span></code>
and <code class="docutils literal notranslate"><span class="pre">idaes.core</span></code> to build a flowsheet model.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyomo.environ</span> <span class="kn">import</span> <span class="n">ConcreteModel</span>
<span class="kn">from</span> <span class="nn">idaes.core</span> <span class="kn">import</span> <span class="n">FlowsheetBlock</span>
</pre></div>
</div>
<p>Next, we create <code class="docutils literal notranslate"><span class="pre">ConcreteModel</span></code> and a steady-state <code class="docutils literal notranslate"><span class="pre">FlowsheetBlock</span></code>
to contain our example, ot which we attach an instance of our new
<code class="docutils literal notranslate"><span class="pre">HDAPhysicalParameterBlock</span></code>.</p>
<p>We can then create an instance of the <code class="docutils literal notranslate"><span class="pre">HDAStateBlock</span></code> directly from
the parameter block using the <code class="docutils literal notranslate"><span class="pre">build_state_block</span></code> method. This uses
the reference to the State Block class that we attached ot the Physical
Parameter Block earlier in the example to automatically create an
instance of the correct class. Note that we index the State Block by the
time domain, so that it looks like a typical state block in a flowsheet,
and we set <code class="docutils literal notranslate"><span class="pre">defined_state</span> <span class="pre">=</span> <span class="pre">True</span></code> so that we can set values for all
the component mole fractions later.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">()</span>

<span class="n">m</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">FlowsheetBlock</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dynamic&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>

<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">thermo_props</span> <span class="o">=</span> <span class="n">HDAParameterBlock</span><span class="p">()</span>

<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">thermo_props</span><span class="o">.</span><span class="n">build_state_block</span><span class="p">(</span>
    <span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;defined_state&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
</pre></div>
</div>
<p>We now have an instance of our new State Block in our flowsheet, so
let’s display it and see what it contains.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Block</span> <span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>

  <span class="n">Variables</span><span class="p">:</span>
    <span class="n">flow_mol</span> <span class="p">:</span> <span class="n">Molar</span> <span class="n">flow</span> <span class="n">rate</span>
        <span class="n">Size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Units</span><span class="o">=</span><span class="n">mol</span><span class="o">/</span><span class="n">s</span>
        <span class="n">Key</span>  <span class="p">:</span> <span class="n">Lower</span> <span class="p">:</span> <span class="n">Value</span> <span class="p">:</span> <span class="n">Upper</span> <span class="p">:</span> <span class="n">Fixed</span> <span class="p">:</span> <span class="n">Stale</span> <span class="p">:</span> <span class="n">Domain</span>
        <span class="kc">None</span> <span class="p">:</span> <span class="mf">1e-08</span> <span class="p">:</span>     <span class="mi">1</span> <span class="p">:</span>  <span class="mi">1000</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
    <span class="n">mole_frac_comp</span> <span class="p">:</span> <span class="n">Component</span> <span class="n">mole</span> <span class="n">fractions</span>
        <span class="n">Size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">Index</span><span class="o">=</span><span class="n">fs</span><span class="o">.</span><span class="n">thermo_props</span><span class="o">.</span><span class="n">component_list</span>
        <span class="n">Key</span>      <span class="p">:</span> <span class="n">Lower</span> <span class="p">:</span> <span class="n">Value</span> <span class="p">:</span> <span class="n">Upper</span> <span class="p">:</span> <span class="n">Fixed</span> <span class="p">:</span> <span class="n">Stale</span> <span class="p">:</span> <span class="n">Domain</span>
         <span class="n">benzene</span> <span class="p">:</span>     <span class="mi">0</span> <span class="p">:</span>   <span class="mf">0.2</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
        <span class="n">diphenyl</span> <span class="p">:</span>     <span class="mi">0</span> <span class="p">:</span>   <span class="mf">0.2</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
        <span class="n">hydrogen</span> <span class="p">:</span>     <span class="mi">0</span> <span class="p">:</span>   <span class="mf">0.2</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
         <span class="n">methane</span> <span class="p">:</span>     <span class="mi">0</span> <span class="p">:</span>   <span class="mf">0.2</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
         <span class="n">toluene</span> <span class="p">:</span>     <span class="mi">0</span> <span class="p">:</span>   <span class="mf">0.2</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
    <span class="n">pressure</span> <span class="p">:</span> <span class="n">State</span> <span class="n">pressure</span>
        <span class="n">Size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Units</span><span class="o">=</span><span class="n">Pa</span>
        <span class="n">Key</span>  <span class="p">:</span> <span class="n">Lower</span>  <span class="p">:</span> <span class="n">Value</span>  <span class="p">:</span> <span class="n">Upper</span>  <span class="p">:</span> <span class="n">Fixed</span> <span class="p">:</span> <span class="n">Stale</span> <span class="p">:</span> <span class="n">Domain</span>
        <span class="kc">None</span> <span class="p">:</span> <span class="mi">101325</span> <span class="p">:</span> <span class="mi">101325</span> <span class="p">:</span> <span class="mi">400000</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
    <span class="n">temperature</span> <span class="p">:</span> <span class="n">State</span> <span class="n">temperature</span>
        <span class="n">Size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Units</span><span class="o">=</span><span class="n">K</span>
        <span class="n">Key</span>  <span class="p">:</span> <span class="n">Lower</span>  <span class="p">:</span> <span class="n">Value</span>  <span class="p">:</span> <span class="n">Upper</span> <span class="p">:</span> <span class="n">Fixed</span> <span class="p">:</span> <span class="n">Stale</span> <span class="p">:</span> <span class="n">Domain</span>
        <span class="kc">None</span> <span class="p">:</span> <span class="mf">298.15</span> <span class="p">:</span> <span class="mf">298.15</span> <span class="p">:</span>  <span class="mi">1500</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
    <span class="n">dens_mol</span> <span class="p">:</span> <span class="n">Mixture</span> <span class="n">density</span>
        <span class="n">Size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Units</span><span class="o">=</span><span class="n">mol</span><span class="o">/</span><span class="n">m</span><span class="o">**</span><span class="mi">3</span>
        <span class="n">Key</span>  <span class="p">:</span> <span class="n">Lower</span> <span class="p">:</span> <span class="n">Value</span> <span class="p">:</span> <span class="n">Upper</span> <span class="p">:</span> <span class="n">Fixed</span> <span class="p">:</span> <span class="n">Stale</span> <span class="p">:</span> <span class="n">Domain</span>
        <span class="kc">None</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span>     <span class="mi">1</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>

  <span class="n">Objectives</span><span class="p">:</span>
    <span class="kc">None</span>

  <span class="n">Constraints</span><span class="p">:</span>
    <span class="n">ideal_gas_eq</span> <span class="p">:</span> <span class="n">Size</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">Key</span>  <span class="p">:</span> <span class="n">Lower</span> <span class="p">:</span> <span class="n">Body</span>             <span class="p">:</span> <span class="n">Upper</span>
        <span class="kc">None</span> <span class="p">:</span>   <span class="mf">0.0</span> <span class="p">:</span> <span class="mf">98846.0429704433</span> <span class="p">:</span>   <span class="mf">0.0</span>
</pre></div>
</div>
<p>We can see that our State Block contains a single point in time, which
in turn contains the five variables. These are our four state variables
(molar flow rate, component mole fraction, temperature and pressure) as
well as the mixture density. We also have a single constraint, which is
the ideal gas equation used to calculate density. Note that we don’t see
the component molecular weights as they are <code class="docutils literal notranslate"><span class="pre">Params</span></code> (<code class="docutils literal notranslate"><span class="pre">References</span></code>
take on the appearance of the component being referenced) or the molar
enthalpy as it is an <code class="docutils literal notranslate"><span class="pre">Expression</span></code>, not a variable (plus it hasn’t been
constructed yet as we haven’t asked for it).</p>
<p>Next, let us check the degrees of freedom in our State Block.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom: &quot;</span><span class="p">,</span> <span class="n">degrees_of_freedom</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Degrees</span> <span class="n">of</span> <span class="n">freedom</span><span class="p">:</span>  <span class="mi">2</span>
</pre></div>
</div>
<p>This is unexpected: the <code class="docutils literal notranslate"><span class="pre">degrees_of_freedom</span></code> method is saying there
are only 2 degrees of freedom in our State Block, but there are 8 state
variables.</p>
<p>However, if we think about the constraints we have written, we are only
actually using 2 of the state variables in any constraint (temperature
and pressure appear in the ideal gas equation). The molar flowrate and
component mole fractions are not actually used anywhere in our model, so
they have been excluded from the degrees of freedom calculation. In
Pyomo terminology, these variables are “Stale”, and they will not be
sent to the solver when it is called. Thus, the two degrees of freedom
is in fact correct.</p>
<p>Note that this is only the case because our property package is so
simple. Also, the specific enthalpy calculation depends on the component
mole fractions, so whilst we could solve the State Block by only
specifying temperature and pressure, the value of the specific molar
enthalpy would be meaningless.</p>
<p>So, lets set some values for all of the state variables as shown below.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flow_mol</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">temperature</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pressure</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mi">350000</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="s2">&quot;benzene&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="s2">&quot;toluene&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="s2">&quot;hydrogen&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="s2">&quot;methane&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mole_frac_comp</span><span class="p">[</span><span class="s2">&quot;diphenyl&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that we have fixed the values for all the state variables, we would
expect that the degrees of freedom should be zero (even though we fixed
all 8 variables, only temperature and pressure actually contribute to
the degrees of freedom). Let’s check this to be sure.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom: &quot;</span><span class="p">,</span> <span class="n">degrees_of_freedom</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Degrees</span> <span class="n">of</span> <span class="n">freedom</span><span class="p">:</span>  <span class="mi">0</span>
</pre></div>
</div>
<p>We have the expected zero degrees of freedom, so lets try to run the
initialization routine we defined and see if we can solve our model.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

<span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dens_mol</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2022</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">08</span> <span class="mi">01</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">43</span> <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">idaes</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">:</span> <span class="n">Properties</span> <span class="n">Initialized</span> <span class="n">optimal</span> <span class="o">-</span> <span class="n">Optimal</span> <span class="n">Solution</span> <span class="n">Found</span><span class="o">.</span>
<span class="mi">2022</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">08</span> <span class="mi">01</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">43</span> <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">idaes</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">:</span> <span class="n">Initialization</span> <span class="n">Complete</span>
<span class="n">dens_mol</span> <span class="p">:</span> <span class="n">Mixture</span> <span class="n">density</span>
    <span class="n">Size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Units</span><span class="o">=</span><span class="n">mol</span><span class="o">/</span><span class="n">m</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">Key</span>  <span class="p">:</span> <span class="n">Lower</span> <span class="p">:</span> <span class="n">Value</span>             <span class="p">:</span> <span class="n">Upper</span> <span class="p">:</span> <span class="n">Fixed</span> <span class="p">:</span> <span class="n">Stale</span> <span class="p">:</span> <span class="n">Domain</span>
    <span class="kc">None</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="mf">84.19064853145991</span> <span class="p">:</span>  <span class="kc">None</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span> <span class="kc">False</span> <span class="p">:</span>  <span class="n">Reals</span>
</pre></div>
</div>
<p>If all went according to plan, we should see that the initialization
routine reports an optimal solution found, and that the calculated molar
density is 84.19 <span class="math notranslate nohighlight">\(mol/m^3\)</span>. So far so good, but let’s see if the
calculation for specific enthalpy works by displaying its value as well.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">enth_mol</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enth_mol</span> <span class="p">:</span> <span class="n">Size</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">Key</span>  <span class="p">:</span> <span class="n">Value</span>
    <span class="kc">None</span> <span class="p">:</span> <span class="o">-</span><span class="mf">22169.95123146947</span>
</pre></div>
</div>
<p>We should hopefully see a value of -22170 <span class="math notranslate nohighlight">\(J/mol\)</span>, meaning our
property package appears to be working.</p>
<p>However, whilst the code ran smoothly and we managed to solve the model,
there is still the possibility that an error slipped in somewhere. There
are many things we could do to verify and validate our model, but a
simple place to start is to check that all the units of measurement in
the model make sense. When we declared all the variables in our model,
we assigned them units of measurement so we would expect that the units
should be consistent in all our model equations.</p>
<p>Pyomo contains a useful tool for automatically verifying that the units
of measurement are consistent, so lets import it here and run it over
our model.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyomo.util.check_units</span> <span class="kn">import</span> <span class="n">assert_units_consistent</span>

<span class="n">assert_units_consistent</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>If all went according to plan, the <code class="docutils literal notranslate"><span class="pre">assert_units_consistent</span></code> method
will return nothing, indicating that our units are consistent, and thus
that the first step in verifying our model is complete. If our units
were not consistent, we would have seen an error telling us that the
units of our model were not consistent, and a pointer to the offending
constraint and the inconsistent units (Pyomo only returns the first
error encountered, so fixing the first error may reveal another).</p>
</section>
<section id="concluding-remarks">
<h1>Concluding Remarks<a class="headerlink" href="#concluding-remarks" title="Permalink to this headline">¶</a></h1>
<p>The above example has hopefully introduced you to the basic requirements
for creating your own custom physical property packages. However, it is
probably clear that it requires a significant amount of effort to write
your own property packages, thus users are encouraged to look into the
IDAES Generic Properties Framework if they are not already familiar with
this.</p>
<p>The IDAES Generic Properties Framework is designed to automatically
generate user-defined property packages for common applications based on
a single configuration file. Users provide a list of phases and
components of interest, and select from a library of common forms for
properties of interest, and the Generic Properties Framework then does
the hard work of assembling the necessary code to construct the desired
model.</p>
<p>To demonstrate the application of the Generic Properties Framework, an
equivalent property package to the one we wrote above can be generated
using the following configuration dict.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import Generic Property Framework Libraries</span>
<span class="kn">from</span> <span class="nn">idaes.core</span> <span class="kn">import</span> <span class="n">VaporPhase</span><span class="p">,</span> <span class="n">Component</span>

<span class="kn">from</span> <span class="nn">idaes.generic_models.properties.core.state_definitions</span> <span class="kn">import</span> <span class="n">FTPx</span>
<span class="kn">from</span> <span class="nn">idaes.generic_models.properties.core.eos.ideal</span> <span class="kn">import</span> <span class="n">Ideal</span>

<span class="kn">import</span> <span class="nn">idaes.generic_models.properties.core.pure.RPP3</span> <span class="k">as</span> <span class="nn">RPP</span>

<span class="c1"># Build configuration dictionary</span>
<span class="n">configuration</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Specifying components</span>
    <span class="s2">&quot;components&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;benzene&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">Component</span><span class="p">,</span>
                    <span class="s2">&quot;enth_mol_ig_comp&quot;</span><span class="p">:</span> <span class="n">RPP</span><span class="p">,</span>
                    <span class="s2">&quot;parameter_data&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;mw&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">78.1136E-3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
                        <span class="s2">&quot;cp_mol_ig_comp_coeff&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.392E1</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">),</span>
                            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">4.739E-1</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.017E-4</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span>
                            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">7.130E-8</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">4</span><span class="p">)},</span>
                        <span class="s2">&quot;enth_mol_form_vap_comp_ref&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="mf">82.9e3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">)}},</span>
        <span class="s1">&#39;toluene&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">Component</span><span class="p">,</span>
                    <span class="s2">&quot;enth_mol_ig_comp&quot;</span><span class="p">:</span> <span class="n">RPP</span><span class="p">,</span>
                    <span class="s2">&quot;parameter_data&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;mw&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">92.1405E-3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
                        <span class="s2">&quot;cp_mol_ig_comp_coeff&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.435E1</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">),</span>
                            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">5.125E-1</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.765E-4</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span>
                            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">4.911E-8</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">4</span><span class="p">)},</span>
                        <span class="s2">&quot;enth_mol_form_vap_comp_ref&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="mf">50.1e3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">)}},</span>
        <span class="s1">&#39;hydrogen&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">Component</span><span class="p">,</span>
                    <span class="s2">&quot;enth_mol_ig_comp&quot;</span><span class="p">:</span> <span class="n">RPP</span><span class="p">,</span>
                    <span class="s2">&quot;parameter_data&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;mw&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.016e-3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
                        <span class="s2">&quot;cp_mol_ig_comp_coeff&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.714e1</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">),</span>
                            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">9.274e-3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.381e-5</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span>
                            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">7.645e-9</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">4</span><span class="p">)},</span>
                        <span class="s2">&quot;enth_mol_form_vap_comp_ref&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">)}},</span>
        <span class="s1">&#39;methane&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">Component</span><span class="p">,</span>
                    <span class="s2">&quot;enth_mol_ig_comp&quot;</span><span class="p">:</span> <span class="n">RPP</span><span class="p">,</span>
                    <span class="s2">&quot;parameter_data&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;mw&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">16.043e-3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
                        <span class="s2">&quot;cp_mol_ig_comp_coeff&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.925e1</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">),</span>
                            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">5.213e-2</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">8.855e-4</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span>
                            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.132e-8</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">4</span><span class="p">)},</span>
                        <span class="s2">&quot;enth_mol_form_vap_comp_ref&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="o">-</span><span class="mf">75e3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">)}},</span>
        <span class="s1">&#39;diphenyl&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">Component</span><span class="p">,</span>
                    <span class="s2">&quot;enth_mol_ig_comp&quot;</span><span class="p">:</span> <span class="n">RPP</span><span class="p">,</span>
                    <span class="s2">&quot;parameter_data&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;mw&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">154.212e-4</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
                        <span class="s2">&quot;cp_mol_ig_comp_coeff&quot;</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">9.707e1</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">),</span>
                            <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.106e0</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                            <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">8.855e-4</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span>
                            <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.790e-7</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="o">**</span><span class="mi">4</span><span class="p">)},</span>
                        <span class="s2">&quot;enth_mol_form_vap_comp_ref&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="o">-</span><span class="mf">180e3</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">J</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">)}}},</span>

    <span class="c1"># Specifying phases</span>
    <span class="s2">&quot;phases&quot;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;Vap&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">VaporPhase</span><span class="p">,</span>
                        <span class="s2">&quot;equation_of_state&quot;</span><span class="p">:</span> <span class="n">Ideal</span><span class="p">}},</span>

    <span class="c1"># Set base units of measurement</span>
    <span class="s2">&quot;base_units&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                   <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                   <span class="s2">&quot;mass&quot;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">kg</span><span class="p">,</span>
                   <span class="s2">&quot;amount&quot;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span>
                   <span class="s2">&quot;temperature&quot;</span><span class="p">:</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">},</span>

    <span class="c1"># Specifying state definition</span>
    <span class="s2">&quot;state_definition&quot;</span><span class="p">:</span> <span class="n">FTPx</span><span class="p">,</span>
    <span class="s2">&quot;state_bounds&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;flow_mol&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">mol</span><span class="o">/</span><span class="n">pyunits</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
                     <span class="s2">&quot;temperature&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">298.15</span><span class="p">,</span> <span class="mf">298.15</span><span class="p">,</span> <span class="mi">1500</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">),</span>
                     <span class="s2">&quot;pressure&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">101325</span><span class="p">,</span> <span class="mi">101325</span><span class="p">,</span> <span class="mi">400000</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">Pa</span><span class="p">)},</span>
    <span class="s2">&quot;pressure_ref&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">101325</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">Pa</span><span class="p">),</span>
    <span class="s2">&quot;temperature_ref&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">298.15</span><span class="p">,</span> <span class="n">pyunits</span><span class="o">.</span><span class="n">K</span><span class="p">)}</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright DOE Institute for the Design of Advanced Energy Systems (IDAES), 2018-2020.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<div id="bottombanner">
    The IDAES team:
    <ul>
        <li>National Energy Technology Laboratory (Lead)</li>
        <li>Sandia National Laboratory</li>
        <li>Lawrence Berkeley National Laboratory</li>
        <li>Carnegie-Mellon University (subcontract to LBNL)</li>
        <li>West Virginia University (subcontract to LBNL)</li>
    </ul>
    <div id="contactinfo">
        General, background and overview information<br/> is available at the
        <a href="https://www.idaes.org>">IDAES main website</a>
    </div>
</div>


</body>
</html>